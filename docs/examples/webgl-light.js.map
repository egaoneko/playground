{"version":3,"sources":["webpack:///../src/pg/math/vector3.js","webpack:///./utils/webgl/mesh-utils.js","webpack:///./webgl-light.js"],"names":["Vector3","x","y","z","this","prototype","divide","scala","Error","cross","vector","const","length","Math","sqrt","normalize","setupSphereMesh","gl","buffers","n","options","color","Object","assign","translation","radius","division","smoothShading","textured","latitudeBands","longitudeBands","vertexPositionData","colorData","normalData","indexData","textureData","trianglesNormalBuffers","trianglesColorBuffers","trianglesVerticeBuffers","trianglesTexCoordBuffers","vertexIndexBuffers","latNumber","theta","PI","sinTheta","sin","cosTheta","cos","longNumber","phi","sinPhi","push","let","first","second","origVertices","indices","vertices","i","a","calculateFlattenedVertices","origNormals","normals","b","c","n1","vector3","n2","n3","nx","ny","nz","v3","calculatePerFaceNormals","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","itemSize","numItems","ELEMENT_ARRAY_BUFFER","Uint16Array","STREAM_DRAW","canvas","container","glProgram","fragmentShader","vertexShader","vertexPositionAttribute","vertexNormalAttribute","vertexColorAttribute","pMatrix","mat4","create","mvMatrix","normalMatrix","mat3","angle","paused","SHADER","flat","phong","gouraud_phong","phong_phong","attenuation","spotlight","fog","fog_spotlight","radios","document","querySelectorAll","changeHandler","deleteProgram","createProgram","value","type","vsSource","fsSource","makeShader","VERTEX_SHADER","FRAGMENT_SHADER","attachShader","linkProgram","getProgramParameter","LINK_STATUS","alert","useProgram","pMatrixUniform","getUniformLocation","mvMatrixUniform","normalMatrixUniform","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","window","addEventListener","querySelector","width","clientWidth","height","clientHeight","getContext","e","console","error","size","j","setupPlaneMesh","getAttribLocation","enableVertexAttribArray","animLoop","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","DEPTH_TEST","viewport","perspective","identity","translate","rotate","invertedMatrix","fromMat4","invert","transpose","uniformMatrix4fv","uniformMatrix3fv","vertexAttribPointer","FLOAT","disable","BLEND","blendFunc","SRC_ALPHA","ONE","blendEquation","FUNC_ADD","drawElements","TRIANGLES","UNSIGNED_SHORT","drawArrays","drawScene","requestAnimationFrame","evt","keyCode","Array","forEach","call","radio"],"mappings":"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","file":"webgl-light.js","sourcesContent":["/**\n * @module pg/math/vector3\n */\n\n/**\n * @classdesc\n * Vector 3D\n *\n * @api\n */\n\nexport default class Vector3 {\n  constructor(x = 0, y = 0, z = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  /**\n   * Divide by number\n   * @param {number} scala number for dividing\n   * @return {Vector3} this\n   * @api\n   */\n  divide(scala) {\n    if (typeof scala !== 'number') {\n      throw new Error(`invalid input: ${scala}`);\n    }\n\n    this.x /= scala;\n    this.y /= scala;\n    this.z /= scala;\n\n    return this;\n  }\n\n  /**\n   * Get crossed vector.\n   * @param {Vector3} vector vector for cross\n   * @return {Vector3} this\n   * @api\n   */\n  cross(vector) {\n    const x = this.x;\n    const y = this.y;\n    const z = this.z;\n\n    if (!(vector instanceof Vector3)) {\n      throw new Error(`invalid input: ${vector}`);\n    }\n\n    this.x = y * vector.z - z * vector.y;\n    this.y = z * vector.x - x * vector.z;\n    this.z = x * vector.y - y * vector.x;\n  }\n\n  /**\n   * Get length of vector.\n   * @return {number} length\n   * @api\n   */\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n\n  /**\n   * Get normalized vector\n   * @return {Vector3} normalized vector\n   * @api\n   */\n  normalize() {\n    return this.divide(this.length());\n  }\n}\n","import Vector3 from \"../../../src/pg/math/vector3\";\n\nexport function setupPlaneMesh(gl, buffers, n, options) {\n  options = Object.assign({}, {\n    size: 10.0,\n    color: [0.5, 0.5, 1.0, 1.0],\n    translation: [0.0, 0.0, 0.0],\n    textured: false,\n  }, options);\n\n  const size = options.size;\n  const color = options.color;\n  const translation = options.translation;\n  const textured = options.textured;\n\n  let vertexPositionData;\n  let indexData;\n  let textureData;\n  const normalData = [];\n  const colorData = [];\n\n  const trianglesNormalBuffers = buffers.trianglesNormalBuffers;\n  const trianglesColorBuffers = buffers.trianglesColorBuffers;\n  const trianglesVerticeBuffers = buffers.trianglesVerticeBuffers;\n  const trianglesTexCoordBuffers = buffers.trianglesTexCoordBuffers;\n  const vertexIndexBuffers = buffers.vertexIndexBuffers;\n\n  //plane\n  for (let i = 0; i < 5; ++i) {\n    normalData.push(0.0);\n    normalData.push(1.0);\n    normalData.push(0.0);\n    colorData.push(color[0]);\n    colorData.push(color[1]);\n    colorData.push(color[2]);\n    colorData.push(color[3]);\n  }\n\n  vertexPositionData = [\n    0.0, 0.0, 0.0,\n    -size, 0.0, -size,\n    size, 0.0, -size,\n    size, 0.0, size,\n    -size, 0.0, size\n  ];\n\n  textureData = [\n    0.0, 0.0,\n    -size, -size,\n    size, -size,\n    size, size,\n    -size, size\n  ];\n\n\n  for (var j = 0; j < vertexPositionData.length; j += 3) {\n    vertexPositionData[j] += translation[0];\n    vertexPositionData[j + 1] += translation[1];\n    vertexPositionData[j + 2] += translation[2];\n  }\n\n  indexData = [0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 1];\n\n  trianglesNormalBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesNormalBuffers[n]);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);\n  trianglesNormalBuffers[n].itemSize = 3;\n  trianglesNormalBuffers[n].numItems = normalData.length / 3;\n\n  trianglesColorBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesColorBuffers[n]);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData), gl.STATIC_DRAW);\n  trianglesColorBuffers[n].itemSize = 4;\n  trianglesColorBuffers[n].numItems = colorData.length / 4;\n\n  trianglesVerticeBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffers[n]);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);\n  trianglesVerticeBuffers[n].itemSize = 3;\n  trianglesVerticeBuffers[n].numItems = vertexPositionData.length / 3;\n\n  if (textured) {\n    trianglesTexCoordBuffers[n] = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesTexCoordBuffers[n]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureData), gl.STATIC_DRAW);\n    trianglesTexCoordBuffers[n].itemSize = 2;\n    trianglesTexCoordBuffers[n].numItems = textureData.length / 2;\n  }\n\n  vertexIndexBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffers[n]);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);\n  vertexIndexBuffers[n].itemSize = 3;\n  vertexIndexBuffers[n].numItems = indexData.length;\n}\n\nexport function setupSphereMesh(gl, buffers, n, options) {\n  options = Object.assign({}, {\n    color: [1.0, 0.0, 0.0, 1.0],\n    translation: [0.0, 0.0, 0.0],\n    radius: 1.0,\n    division: 30,\n    smoothShading: true,\n    textured: false,\n  }, options);\n\n  const color = options.color;\n  const translation = options.translation;\n  const radius = options.radius;\n  const division = options.division;\n  const smoothShading = options.smoothShading;\n  const textured = options.textured;\n\n  let latitudeBands = division;\n  let longitudeBands = division;\n\n  let vertexPositionData = [];\n  let colorData = [];\n  let normalData = [];\n  const indexData = [];\n  const textureData = [];\n\n  const trianglesNormalBuffers = buffers.trianglesNormalBuffers;\n  const trianglesColorBuffers = buffers.trianglesColorBuffers;\n  const trianglesVerticeBuffers = buffers.trianglesVerticeBuffers;\n  const trianglesTexCoordBuffers = buffers.trianglesTexCoordBuffers;\n  const vertexIndexBuffers = buffers.vertexIndexBuffers;\n\n  //modified from http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere\n  for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n    const theta = latNumber * Math.PI / latitudeBands;\n    const sinTheta = Math.sin(theta);\n    const cosTheta = Math.cos(theta);\n\n    for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n      const phi = longNumber * 2 * Math.PI / longitudeBands;\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n\n      const x = cosPhi * sinTheta;\n      const y = cosTheta;\n      const z = sinPhi * sinTheta;\n      // const u = 1 - (longNumber / longitudeBands);\n      // const v = latNumber / latitudeBands;\n\n      textureData.push((x + 1.0) * .5);\n      textureData.push((y + 1.0) * .5);\n\n      normalData.push(x);\n      normalData.push(y);\n      normalData.push(z);\n      colorData.push(color[0]);\n      colorData.push(color[1]);\n      colorData.push(color[2]);\n      colorData.push(color[3]);\n      vertexPositionData.push(radius * x + translation[0]);\n      vertexPositionData.push(radius * y + translation[1]);\n      vertexPositionData.push(radius * z + translation[2]);\n    }\n  }\n\n  for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {\n    for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {\n      const first = (latNumber * (longitudeBands + 1)) + longNumber;\n      const second = first + longitudeBands + 1;\n      indexData.push(first);\n      indexData.push(second);\n      indexData.push(first + 1);\n\n      indexData.push(second);\n      indexData.push(second + 1);\n      indexData.push(first + 1);\n    }\n  }\n\n  if (!smoothShading) {\n    vertexPositionData = calculateFlattenedVertices(vertexPositionData, indexData);\n    colorData = [];\n    for (let i = 0; i < indexData.length; ++i) {\n      colorData.push(color[0]);\n      colorData.push(color[1]);\n      colorData.push(color[2]);\n      colorData.push(color[3]);\n    }\n    normalData = calculatePerFaceNormals(normalData, indexData);\n  }\n\n  trianglesNormalBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesNormalBuffers[n]);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);\n  trianglesNormalBuffers[n].itemSize = 3;\n  trianglesNormalBuffers[n].numItems = normalData.length / 3;\n\n  trianglesColorBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesColorBuffers[n]);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData), gl.STATIC_DRAW);\n  trianglesColorBuffers[n].itemSize = 4;\n  trianglesColorBuffers[n].numItems = colorData.length / 4;\n\n  trianglesVerticeBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffers[n]);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);\n  trianglesVerticeBuffers[n].itemSize = 3;\n  trianglesVerticeBuffers[n].numItems = vertexPositionData.length / 3;\n\n  if (textured) {\n    trianglesTexCoordBuffers[n] = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesTexCoordBuffers[n]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureData), gl.STATIC_DRAW);\n    trianglesTexCoordBuffers[n].itemSize = 2;\n    trianglesTexCoordBuffers[n].numItems = textureData.length / 2;\n  }\n\n  vertexIndexBuffers[n] = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffers[n]);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);\n  vertexIndexBuffers[n].itemSize = 3;\n  vertexIndexBuffers[n].numItems = indexData.length;\n}\n\nfunction calculateFlattenedVertices(origVertices, indices) {\n  const vertices = [];\n  for (let i = 0; i < indices.length; ++i) {\n    const a = indices[i] * 3;\n    vertices.push(origVertices[a]);\n    vertices.push(origVertices[a + 1]);\n    vertices.push(origVertices[a + 2]);\n  }\n  return vertices;\n}\n\nfunction calculatePerFaceNormals(origNormals, indices) {\n  const normals = [];\n  for (let i = 0; i < indices.length; i += 3) {\n    const a = indices[i] * 3;\n    const b = indices[i + 1] * 3;\n    const c = indices[i + 2] * 3;\n\n    const n1 = new Vector3(origNormals[a], origNormals[a + 1], origNormals[a + 2]);\n    const n2 = new Vector3(origNormals[b], origNormals[b + 1], origNormals[b + 2]);\n    const n3 = new Vector3(origNormals[c], origNormals[c + 1], origNormals[c + 2]);\n\n    const nx = (n1.x + n2.x + n3.x) / 3;\n    const ny = (n1.y + n2.y + n3.y) / 3;\n    const nz = (n1.z + n2.z + n3.z) / 3;\n\n    const v3 = new Vector3(nx, ny, nz);\n    normals.push(v3.x);\n    normals.push(v3.y);\n    normals.push(v3.z);\n\n    normals.push(v3.x);\n    normals.push(v3.y);\n    normals.push(v3.z);\n\n    normals.push(v3.x);\n    normals.push(v3.y);\n    normals.push(v3.z);\n  }\n  return normals;\n}\n","import {setupPlaneMesh, setupSphereMesh} from \"./utils/webgl/mesh-utils\";\n\nlet gl = null;\nlet canvas = null;\nlet container = null;\nlet glProgram = null;\nlet fragmentShader = null;\nlet vertexShader = null;\n\nlet vertexPositionAttribute = null;\nlet vertexNormalAttribute = null;\nlet vertexColorAttribute = null;\nlet trianglesVerticeBuffers = [];\nlet trianglesNormalBuffers = [];\nlet trianglesColorBuffers = [];\nlet vertexIndexBuffers = [];\n\nlet pMatrix = mat4.create();\nlet mvMatrix = mat4.create();\nlet normalMatrix = mat3.create();\n\nlet angle = 0.0;\n\nlet paused = false;\n\nconst SHADER = {\n  flat: {\n    vertexShader: flatVertexShaderSource(),\n    fragmentShader: flatFragmentShaderSource()\n  },\n  phong: {\n    vertexShader: phongVertexShaderSource(),\n    fragmentShader: phongFragmentShaderSource()\n  },\n  gouraud_phong: {\n    vertexShader: gouraudPhongVertexShaderSource(),\n    fragmentShader: gouraudPhongFragmentShaderSource()\n  },\n  phong_phong: {\n    vertexShader: phongPhongVertexShaderSource(),\n    fragmentShader: phongPhongFragmentShaderSource()\n  },\n  attenuation: {\n    vertexShader: attenuationVertexShaderSource(),\n    fragmentShader: attenuationFragmentShaderSource()\n  },\n  spotlight: {\n    vertexShader: spotlightVertexShaderSource(),\n    fragmentShader: spotlightFragmentShaderSource()\n  },\n  fog: {\n    vertexShader: fogVertexShaderSource(),\n    fragmentShader: fogFragmentShaderSource()\n  },\n  fog_spotlight: {\n    vertexShader: fogSpotlightVertexShaderSource(),\n    fragmentShader: fogSpotlightFragmentShaderSource()\n  }\n};\n\nconst radios = document.querySelectorAll('input[type=radio][name=\"light\"]');\n\nwindow.addEventListener('load', initWebGL);\ndocument.addEventListener('keyup', (evt) => {\n  switch (evt.keyCode) {\n    case 80: // 'p'\n      paused = !paused;\n      break;\n    default:\n      break;\n  }\n});\n\nfunction changeHandler() {\n  gl.deleteProgram(glProgram);\n  createProgram(this.value);\n}\n\nArray.prototype.forEach.call(radios, function(radio) {\n  radio.addEventListener('change', changeHandler);\n});\n\nfunction initWebGL() {\n  canvas = document.querySelector('#canvas');\n  container = document.querySelector('#container');\n  canvas.width = container.clientWidth;\n  canvas.height = container.clientHeight;\n\n  try {\n    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  } catch (e) {\n    console.error(e);\n  }\n\n  if (gl) {\n    initShaders();\n    setupMeshes();\n\n    (function animLoop() {\n\n      if (!paused) {\n        setupWebGL();\n        drawScene();\n      }\n\n      requestAnimationFrame(animLoop);\n    })();\n  }\n}\n\nfunction setupWebGL() {\n  // set the clear color to a shade of green\n  gl.clearColor(0.7, 0.7, 0.7, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.enable(gl.DEPTH_TEST);\n\n  gl.viewport(0, 0, canvas.width, canvas.height);\n  mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);\n}\n\nfunction initShaders() {\n  createProgram('flat');\n}\n\nfunction createProgram(type) {\n  // create program\n  glProgram = gl.createProgram();\n  attachShader(glProgram, type);\n  // use program\n  gl.useProgram(glProgram);\n  getMatrixUniforms();\n}\n\nfunction attachShader(glProgram, type) {\n  // get shader source\n  const vsSource = SHADER[type].vertexShader;\n  const fsSource = SHADER[type].fragmentShader;\n\n  // compile shaders\n  vertexShader = makeShader(vsSource, gl.VERTEX_SHADER);\n  fragmentShader = makeShader(fsSource, gl.FRAGMENT_SHADER);\n\n  // attach and link shaders to the program\n  gl.attachShader(glProgram, vertexShader);\n  gl.attachShader(glProgram, fragmentShader);\n  gl.linkProgram(glProgram);\n\n  if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n    alert('Unable to initialize the shader program.');\n  }\n}\n\nfunction makeShader(source, type) {\n  // compile the shader\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);\n  }\n\n  return shader;\n}\n\nfunction setupMeshes() {\n  setupSphereMesh(\n    gl,\n    {\n      trianglesNormalBuffers,\n      trianglesColorBuffers,\n      trianglesVerticeBuffers,\n      vertexIndexBuffers,\n    },\n    0,\n    {\n      translation: [-1.0, -0.75, 0.0],\n      color: [1.0, 0.0, 0.0, 1.0],\n      division: 20,\n      smoothShading: false\n    }\n  );\n\n  setupSphereMesh(\n    gl,\n    {\n      trianglesNormalBuffers,\n      trianglesColorBuffers,\n      trianglesVerticeBuffers,\n      vertexIndexBuffers,\n    },\n    1,\n    {\n      translation: [0.0, 0.0, 1.0],\n      color: [0.0, 1.0, 0.0, 1.0],\n      division: 10,\n      smoothShading: false\n    }\n  );\n\n  setupSphereMesh(\n    gl,\n    {\n      trianglesNormalBuffers,\n      trianglesColorBuffers,\n      trianglesVerticeBuffers,\n      vertexIndexBuffers,\n    },\n    2,\n    {\n      translation: [1.0, 0.25, -1.0],\n      color: [1.0, 1.0, 0.0, 1.0],\n      division: 5,\n      smoothShading: false\n    }\n  );\n\n  setupSphereMesh(\n    gl,\n    {\n      trianglesNormalBuffers,\n      trianglesColorBuffers,\n      trianglesVerticeBuffers,\n      vertexIndexBuffers,\n    },\n    3,\n    {\n      translation: [-1.0, 1.0, -1.0],\n      color: [1.0, 0.0, 1.0, 1.0],\n    }\n  );\n\n  setupSphereMesh(\n    gl,\n    {\n      trianglesNormalBuffers,\n      trianglesColorBuffers,\n      trianglesVerticeBuffers,\n      vertexIndexBuffers,\n    },\n    4,\n    {\n      translation: [-0.0, 1.75, -0.0],\n      color: [0.0, 1.0, 1.0, 1.0],\n    }\n  );\n\n\n  setupPlaneMesh(\n    gl,\n    {\n      trianglesNormalBuffers,\n      trianglesColorBuffers,\n      trianglesVerticeBuffers,\n      vertexIndexBuffers,\n    },\n    5,\n    {\n      translation: [0.0, -1.0, 0.0],\n    }\n  );\n\n  vertexPositionAttribute = gl.getAttribLocation(glProgram, \"aVertexPosition\");\n  vertexColorAttribute = gl.getAttribLocation(glProgram, \"aVertexColor\");\n  vertexNormalAttribute = gl.getAttribLocation(glProgram, \"aVertexNormal\");\n  gl.enableVertexAttribArray(vertexPositionAttribute);\n  gl.enableVertexAttribArray(vertexColorAttribute);\n  gl.enableVertexAttribArray(vertexNormalAttribute);\n}\n\nfunction drawScene() {\n  // sphere\n  mat4.identity(mvMatrix);\n  mat4.translate(mvMatrix, mvMatrix, [0.0, 0.4, -6.5]);\n  mat4.rotate(mvMatrix, mvMatrix, -0.3, [-0.3, 0.0, 0.2]);\n  mat4.rotate(mvMatrix, mvMatrix, angle, [0.0, 1.0, 0.0]);\n\n  const invertedMatrix = mat3.create();\n  mat3.fromMat4(invertedMatrix, mvMatrix);\n  mat3.invert(normalMatrix, invertedMatrix);\n  mat3.transpose(normalMatrix, normalMatrix);\n  angle += 0.005;\n  setMatrixUniforms();\n\n  for (let i = 0; i < vertexIndexBuffers.length; ++i) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffers[i]);\n    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesColorBuffers[i]);\n    gl.vertexAttribPointer(vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesNormalBuffers[i]);\n    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);\n\n    if (i === 4) {\n      gl.disable(gl.DEPTH_TEST);\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n      gl.blendEquation(gl.FUNC_ADD);\n    } else {\n      gl.disable(gl.BLEND);\n      gl.enable(gl.DEPTH_TEST);\n    }\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffers[i]);\n    if (i > 2) {\n      gl.drawElements(gl.TRIANGLES, vertexIndexBuffers[i].numItems, gl.UNSIGNED_SHORT, 0);\n    } else {\n      gl.drawArrays(gl.TRIANGLES, 0, trianglesVerticeBuffers[i].numItems);\n    }\n  }\n}\n\nfunction getMatrixUniforms() {\n  glProgram.pMatrixUniform = gl.getUniformLocation(glProgram, 'uPMatrix');\n  glProgram.mvMatrixUniform = gl.getUniformLocation(glProgram, 'uMVMatrix');\n  glProgram.normalMatrixUniform = gl.getUniformLocation(glProgram, \"uNormalMatrix\");\n}\n\nfunction setMatrixUniforms() {\n  gl.uniformMatrix4fv(glProgram.pMatrixUniform, false, pMatrix);\n  gl.uniformMatrix4fv(glProgram.mvMatrixUniform, false, mvMatrix);\n  gl.uniformMatrix3fv(glProgram.normalMatrixUniform, false, normalMatrix);\n}\n\nfunction flatVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform mat4 uPMatrix;    \n    uniform mat4 uMVMatrix;\n    uniform mat3 uNormalMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 L;\n    varying highp vec3 N;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      \n      vec3 pointLightPosition = vec3(1.0, 2.0, -1.0);\n      vec3 pointLightDirection = normalize(vec3(pointLightPosition.xyz - aVertexPosition.xyz));\n      vec3 ambientColor = vec3(0.1, 0.1, 0.1);\n      \n      L = vec3(uPMatrix * uMVMatrix * vec4(pointLightDirection, 1.0));\n      N = uNormalMatrix * aVertexNormal;\n      \n      vColor = aVertexColor;\n    }\n  `;\n}\n\nfunction flatFragmentShaderSource() {\n  return `\n    varying highp vec3 vColor;\n    varying highp vec3 N;\n    varying highp vec3 L;\n    \n    void main(void) {\n      highp float lambert = max(dot(normalize(N), normalize(L)), 0.0);\n      gl_FragColor = vec4(vColor * lambert, 1.0);\n    }\n  `;\n}\n\nfunction phongVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform highp mat4 uPMatrix;    \n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      \n      vColor = aVertexColor;\n      vPosition = aVertexPosition;\n      N = aVertexNormal;\n    }\n  `;\n}\n\nfunction phongFragmentShaderSource() {\n  return `\n    uniform highp mat4 uPMatrix;\n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    \n    void main(void) {\n      highp vec3 n = uNormalMatrix * N;\n      \n      highp vec3 pointLightPosition = vec3(1.0, 2.0, -1.0);\n      highp vec3 pointLightDirection = normalize(vec3(pointLightPosition.xyz - vPosition.xyz));\n      \n      highp vec3 L = vec3(uPMatrix * uMVMatrix * vec4(pointLightDirection, 1.0));\n      \n      highp float lambert = max(dot(normalize(n), normalize(L)), 0.0);\n      gl_FragColor = vec4(vColor * lambert, 1.0);\n    }\n  `;\n}\n\nfunction gouraudPhongVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform highp mat4 uPMatrix;    \n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp float diffuseLambert;\n    varying highp float specular;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      vColor = aVertexColor;\n      \n      vec3 pointLightPosition = vec3(1.0, 2.0, -1.0);\n      vec3 pointLightDirection = vec3(pointLightPosition.xyz - aVertexPosition.xyz);\n      \n      vec3 L = vec3(uPMatrix * uMVMatrix * vec4(pointLightDirection, 1.0));\n      vec3 N = normalize(uNormalMatrix * aVertexNormal);\n      vec3 V = -vec3(uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0));\n      \n      L = normalize(L);\n      V = normalize(V); \n      \n      vec3 R = reflect(-L, N);\n      float shininess = 128.0;\n      \n      specular = pow(max(0.0, dot(R, V)), shininess);\n      diffuseLambert = dot(L, N);\n    }\n  `;\n}\n\nfunction gouraudPhongFragmentShaderSource() {\n  return ` \n    varying highp vec3 vColor;\n    varying highp float diffuseLambert;\n    varying highp float specular;\n    \n    void main(void) {\n      highp float AmbientIntensity = 0.3;\n      highp vec3 DiffuseLightIntensity = vec3(0.9, 0.9, 0.9);\n      highp float SpecularIntensity = 0.5;\n      \n      highp vec3 AmbientColour = vec3(0.1, 0.1, 0.1);\n      highp vec3 DiffuseMaterialColour = vColor;\n      highp vec3 SpecularColour = vec3(1.0, 1.0, 1.0);\n      \n      gl_FragColor = vec4(AmbientColour * AmbientIntensity +\n        diffuseLambert * DiffuseMaterialColour * DiffuseLightIntensity +\n        SpecularColour * specular * SpecularIntensity, 1.0);\n    }\n  `;\n}\n\nfunction phongPhongVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform highp mat4 uPMatrix;    \n    uniform highp mat4 uMVMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      \n      vColor = aVertexColor;\n      vPosition = aVertexPosition;\n      N = aVertexNormal;\n    }\n  `;\n}\n\nfunction phongPhongFragmentShaderSource() {\n  return ` \n    uniform highp mat4 uPMatrix;\n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n\n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n\n    void main(void) {\n      highp vec3 pointLightPosition = vec3(5.0, 1.0, 5.0);\n\n      highp vec3 pointLightDirection = vec3(pointLightPosition.xyz - vPosition.xyz);\n      \n      highp mat4 mvp = uPMatrix * uMVMatrix;\n\n      highp vec3 L = vec3(mvp * vec4(pointLightDirection, 1.0));\n      highp vec3 V = -vec3(mvp * vec4(vPosition,1.0));\n\n      highp vec3 l = normalize(L);\n      highp vec3 n = normalize(uNormalMatrix * N);\n      highp vec3 v = normalize(V);\n      \n      highp vec3 R = reflect(l, n);\n\n      highp float diffuseLambert = dot(l,n);\n      highp float Roughness = 1.0;\n      highp float AmbientIntensity = 0.3;\n      highp vec3 DiffuseLightIntensity = vec3(0.9, 0.9, 0.9);\n      highp float SpecularIntensity = 0.5;\n      highp float shininess = 128.0;\n\n      highp float specular = pow( max(0.0,dot(R,v)), shininess);\n\n      highp vec3 AmbientColour = vec3(0.1, 0.1, 0.1);\n      highp vec3 DiffuseMaterialColour = vColor.xyz;\n      highp vec3 SpecularColour = vec3(1.0, 1.0, 1.0);\n    \n      gl_FragColor = vec4(AmbientColour*AmbientIntensity + \n        diffuseLambert * DiffuseMaterialColour*DiffuseLightIntensity +\n        SpecularColour * specular*SpecularIntensity, 1.0);\n    }\n  `;\n}\n\nfunction attenuationVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform highp mat4 uPMatrix;    \n    uniform highp mat4 uMVMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      \n      vColor = aVertexColor;\n      vPosition = aVertexPosition;\n      N = aVertexNormal;\n    }\n  `;\n}\n\nfunction attenuationFragmentShaderSource() {\n  return ` \n    uniform highp mat4 uPMatrix;\n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n\n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n\n    void main(void) {\n      highp vec3 pointLightPosition = vec3(5.0, 1.0, 5.0);\n\n      highp vec3 pointLightDirection = vec3(pointLightPosition.xyz - vPosition.xyz);\n      highp float d = length(pointLightDirection);\n      highp float attenuation = 1.0/(.01 + .01*d+.02*d*d);\n      \n      highp mat4 mvp = uPMatrix * uMVMatrix;\n\n      highp vec3 L = vec3(mvp * vec4(pointLightDirection, 1.0));\n      highp vec3 V = -vec3(mvp * vec4(vPosition,1.0));\n\n      highp vec3 l = normalize(L);\n      highp vec3 n = normalize(uNormalMatrix * N);\n      highp vec3 v = normalize(V);\n      \n      highp vec3 R = reflect(l, n);\n\n      highp float diffuseLambert = dot(l,n);\n      highp float Roughness = 1.0;\n      highp float AmbientIntensity = 0.3;\n      highp vec3 DiffuseLightIntensity = vec3(0.9, 0.9, 0.9);\n      highp float SpecularIntensity = 0.5;\n      highp float shininess = 128.0;\n\n      highp float specular = pow(max(0.0,dot(R,v)), shininess);\n\n      highp vec3 AmbientColour = vec3(0.1, 0.1, 0.1) * attenuation;\n      highp vec3 DiffuseMaterialColour = vColor.xyz * attenuation;\n      highp vec3 SpecularColour = vec3(1.0, 1.0, 1.0) * attenuation;\n    \n      gl_FragColor = vec4(AmbientColour*AmbientIntensity + \n        diffuseLambert * DiffuseMaterialColour*DiffuseLightIntensity +\n        SpecularColour * specular*SpecularIntensity, 1.0);\n    }\n  `;\n}\n\nfunction spotlightVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform highp mat4 uPMatrix;    \n    uniform highp mat4 uMVMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      \n      vColor = aVertexColor;\n      vPosition = aVertexPosition;\n      N = aVertexNormal;\n    }\n  `;\n}\n\nfunction spotlightFragmentShaderSource() {\n  return ` \n    uniform highp mat4 uPMatrix;\n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n\n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n\n    void main(void) {\n      highp vec3 pointLightPosition = vec3(5.0, 1.0, 5.0);\n\n      highp vec3 pointLightDirection = vec3(pointLightPosition.xyz - vPosition.xyz);\n      highp float d = length(pointLightDirection);\n      highp float attenuation = 1.0/(.01 + .01*d + .02*d*d);\n      \n      highp mat4 mvp = uPMatrix * uMVMatrix;\n\n      highp vec3 L = vec3(mvp * vec4(pointLightDirection, 1.0));\n      highp vec3 V = -vec3(mvp * vec4(vPosition,1.0));\n\n      highp vec3 l = normalize(L);\n      highp vec3 n = normalize(uNormalMatrix * N);\n      highp vec3 v = normalize(V);\n      \n      highp vec3 R = reflect(l, n);\n\n      highp float diffuseLambert = dot(l,n);\n      \n      // spotlight\n      highp float spotCosCutoff = 0.6;\n      highp float spotExponent = 2.0;\n      highp vec3 spotDirection = vec3(0.5, 0.5, 0.5);\n      highp float spotEffect = dot(normalize(spotDirection), l);\n      \n      if (diffuseLambert > 0.0) {\n        if(spotEffect > spotCosCutoff) {\n          highp float Roughness = 1.0;\n          highp float AmbientIntensity = 0.3;\n          highp vec3 DiffuseLightIntensity = vec3(0.9, 0.9, 0.9);\n          highp float SpecularIntensity = 0.5;\n          highp float shininess = 32.0;\n\n          highp float specular = pow(max(0.0,dot(R,v)), shininess);\n\n          highp vec3 AmbientColour = vec3(0.1, 0.1, 0.1) * attenuation;\n          highp vec3 DiffuseMaterialColour = vColor.xyz * attenuation;\n          highp vec3 SpecularColour = vec3(1.0, 1.0, 1.0) * attenuation;\n    \n          gl_FragColor = vec4(AmbientColour*AmbientIntensity + \n            diffuseLambert * DiffuseMaterialColour*DiffuseLightIntensity +\n            SpecularColour * specular*SpecularIntensity, 1.0);\n        } else {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n      } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      }\n    } \n  `;\n}\n\nfunction fogVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform highp mat4 uPMatrix;    \n    uniform highp mat4 uMVMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    varying highp float fogZ;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      \n      vColor = aVertexColor;\n      vPosition = aVertexPosition;\n      N = aVertexNormal;\n      fogZ = length(gl_Position.xyz);\n    }\n  `;\n}\n\nfunction fogFragmentShaderSource() {\n  return ` \n    uniform highp mat4 uPMatrix;\n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n\n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    varying highp float fogZ;\n\n    void main(void) {\n      highp vec3 pointLightPosition = vec3(5.0, 1.0, 5.0);\n\n      highp vec3 pointLightDirection = vec3(pointLightPosition.xyz - vPosition.xyz);\n      highp float d = length(pointLightDirection);\n      highp float attenuation = 68.0/(.31 + .01*d+.22*d*d);\n      \n      highp mat4 mvp = uPMatrix * uMVMatrix;\n\n      highp vec3 L = vec3(mvp * vec4(pointLightDirection, 1.0));\n      highp vec3 V = -vec3(mvp * vec4(vPosition,1.0));\n\n      highp vec3 l = normalize(L);\n      highp vec3 n = normalize(uNormalMatrix * N);\n      highp vec3 v = normalize(V);\n      \n      highp vec3 R = reflect(l, n);\n\n      highp float diffuseLambert = dot(l,n);\n      highp float Roughness = 1.0;\n      highp float AmbientIntensity = 0.75;\n      highp vec3 DiffuseLightIntensity = vec3(0.9, 0.9, 0.9);\n      highp float SpecularIntensity = 0.8;\n      highp float shininess = 128.0;\n\n      highp float specular = pow(max(0.0,dot(R,v)), shininess);\n\n      highp vec3 AmbientColour = vec3(0.1, 0.1, 0.1) * attenuation;\n      highp vec3 DiffuseMaterialColour = vColor.xyz * attenuation;\n      highp vec3 SpecularColour = vec3(1.0, 1.0, 1.0) * attenuation;\n      \n      // calculate fog\n      highp float fogDensity = 0.25;\n      highp vec4 fogColor = vec4(0.1, 0.2, 0.1, 0.6);\n      \n      highp float fogFactor = exp(-fogDensity * fogDensity * fogZ * fogZ);\n      fogFactor = clamp(fogFactor, 0.0, 1.0);\n    \n      highp vec4 materialColor = vec4(AmbientColour*AmbientIntensity + \n        diffuseLambert * DiffuseMaterialColour*DiffuseLightIntensity +\n        SpecularColour * specular*SpecularIntensity, 1.0);\n      \n      gl_FragColor = mix(fogColor, materialColor, fogFactor);\n    }\n  `;\n}\n\nfunction fogSpotlightVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexColor;\n    attribute vec3 aVertexNormal;\n\n    uniform highp mat4 uPMatrix;    \n    uniform highp mat4 uMVMatrix;\n    \n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    varying highp float fogZ;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      \n      vColor = aVertexColor;\n      vPosition = aVertexPosition;\n      N = aVertexNormal;\n      fogZ = length(gl_Position.xyz);\n    }\n  `;\n}\n\nfunction fogSpotlightFragmentShaderSource() {\n  return ` \n    uniform highp mat4 uPMatrix;\n    uniform highp mat4 uMVMatrix;\n    uniform highp mat3 uNormalMatrix;\n\n    varying highp vec3 vColor;\n    varying highp vec3 vPosition;\n    varying highp vec3 N;\n    varying highp float fogZ;\n\n    void main(void) {\n      highp vec3 pointLightPosition = vec3(5.0, 1.0, 5.0);\n\n      highp vec3 pointLightDirection = vec3(pointLightPosition.xyz - vPosition.xyz);\n      highp float d = length(pointLightDirection);\n      highp float attenuation = 1.0/(.01 + .01*d + .02*d*d);\n      \n      highp mat4 mvp = uPMatrix * uMVMatrix;\n\n      highp vec3 L = vec3(mvp * vec4(pointLightDirection, 1.0));\n      highp vec3 V = -vec3(mvp * vec4(vPosition,1.0));\n\n      highp vec3 l = normalize(L);\n      highp vec3 n = normalize(uNormalMatrix * N);\n      highp vec3 v = normalize(V);\n      \n      highp vec3 R = reflect(l, n);\n\n      highp float diffuseLambert = dot(l,n);\n      \n      // spotlight\n      highp float spotCosCutoff = 0.6;\n      highp float spotExponent = 2.0;\n      highp vec3 spotDirection = vec3(0.5, 0.5, 0.5);\n      highp float spotEffect = dot(normalize(spotDirection), l);\n      \n      // calculate fog\n      highp float fogDensity = 0.075;\n      highp vec4 fogColor = vec4(0.1, 0.2, 0.1, 0.6);\n      \n      highp float fogFactor = exp(-fogDensity * fogDensity * fogZ * fogZ);\n      fogFactor = clamp(fogFactor, 0.0, 1.0);\n      \n      highp vec4 materialColor = vec4(0.0, 0.0, 0.0, 1.0);\n      \n      if (diffuseLambert > 0.0) {\n        if(spotEffect > spotCosCutoff) {\n          highp float Roughness = 1.0;\n          highp float AmbientIntensity = 0.3;\n          highp vec3 DiffuseLightIntensity = vec3(0.9, 0.9, 0.9);\n          highp float SpecularIntensity = 0.5;\n          highp float shininess = 32.0;\n\n          highp float specular = pow( max(0.0,dot(R,v)), shininess);\n\n          highp vec3 AmbientColour = vec3(0.1, 0.1, 0.1) * attenuation;\n          highp vec3 DiffuseMaterialColour = vColor.xyz * attenuation;\n          highp vec3 SpecularColour = vec3(1.0, 1.0, 1.0) * attenuation;\n    \n          materialColor = vec4(AmbientColour*AmbientIntensity + \n            diffuseLambert * DiffuseMaterialColour*DiffuseLightIntensity +\n            SpecularColour * specular*SpecularIntensity, 1.0);\n        } \n      }\n      \n      gl_FragColor = mix(fogColor, materialColor, fogFactor); \n    } \n  `;\n}\n\n"],"sourceRoot":""}