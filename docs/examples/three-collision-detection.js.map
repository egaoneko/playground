{"version":3,"sources":["webpack:///../src/pg/utils/math.js","webpack:///./three-collision-detection.js"],"names":["randomInt","min","max","Math","floor","random","rotate","velocity","angle","x","cos","y","sin","resolveCollision","particle","otherParticle","const","xVelocityDiff","yVelocityDiff","atan2","m1","mass","m2","u1","u2","v1","v2","vFinal1","vFinal2","__webpack_require__","d","__webpack_exports__","r","renderer","scene","camera","width","height","container","cube","_src_pg_utils_math__WEBPACK_IMPORTED_MODULE_0__","boxSize","boundary","colorSet","particles","Particle","z","dx","dy","dz","radius","color","this","opacity","geometry","THREE","SphereGeometry","material","MeshBasicMaterial","mesh","Mesh","position","set","onWindowResize","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","prototype","update","forEach","isCollided","temp","pow","document","getElementById","Scene","background","Color","PerspectiveCamera","lookAt","grid","GridHelper","add","axes","AxesHelper","WebGLRenderer","antialias","setPixelRatio","window","devicePixelRatio","appendChild","domElement","OrbitControls","screenSpacePanning","BoxGeometry","transparent","wireframe","SceneUtils","createMultiMaterialObject","let","cnt","Object","length","some","p","i","push","loop","draw","addEventListener","init","animate","requestAnimationFrame","render"],"mappings":"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","file":"three-collision-detection.js","sourcesContent":["/**\n * @module pg/utils/math\n */\n\n/**\n * Gets a random integer\n *\n * @param {number} min minimum number.\n * @param {number} max maximum number.\n * @return {number} The random integer number.\n * @api\n */\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Gets convex 2d numbers\n * @param {number} step step.\n * @return {array} The convex 2d numbers.\n * @api\n */\nexport function convex2d(step) {\n  const convex = [];\n\n  for (let i = 0; i < step; i++) {\n    const x = i / step;\n    convex.push([x, 1 - i / step]);\n  }\n  return convex;\n}\n\n/**\n * Rotates coordinate system for velocities\n *\n * Takes velocities and alters them as if the coordinate system they're on was rotated\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} velocity The velocity of an individual particle\n * @param {number} angle The angle of collision between two objects in radians\n * @return {Object} The altered x and y velocities after the coordinate system has been rotated\n */\nexport function rotate(velocity, angle) {\n  return {\n    x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),\n    y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)\n  };\n}\n\n/**\n * Swaps out two colliding particles' x and y velocities after running through\n * an elastic collision reaction equation\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} particle A particle object with x and y coordinates, plus velocity\n * @param {object} otherParticle A particle object with x and y coordinates, plus velocity\n * @return {boolean} success\n */\nexport function resolveCollision(particle, otherParticle) {\n  const xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;\n  const yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;\n\n  const xDist = otherParticle.x - particle.x;\n  const yDist = otherParticle.y - particle.y;\n\n  // Prevent accidental overlap of particles\n  if (xVelocityDiff * xDist + yVelocityDiff * yDist < 0) {\n    return false;\n  }\n\n  // Grab angle between the two colliding particles\n  const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);\n\n  // Store mass in var for better readability in collision equation\n  const m1 = particle.mass;\n  const m2 = otherParticle.mass;\n\n  // Velocity before equation\n  const u1 = rotate(particle.velocity, angle);\n  const u2 = rotate(otherParticle.velocity, angle);\n\n  // Velocity after 1d collision equation\n  const v1 = {x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y};\n  const v2 = {x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y};\n\n  // Final velocity after rotating axis back to original location\n  const vFinal1 = rotate(v1, -angle);\n  const vFinal2 = rotate(v2, -angle);\n\n  // Swap particle velocities for realistic bounce effect\n  particle.velocity.x = vFinal1.x;\n  particle.velocity.y = vFinal1.y;\n\n  otherParticle.velocity.x = vFinal2.x;\n  otherParticle.velocity.y = vFinal2.y;\n  return true;\n}\n","// three\nimport {randomInt} from \"../src/pg/utils/math\";\n\nlet renderer;\nlet scene;\nlet camera;\nlet width;\nlet height;\nlet container;\n\nconst boxSize = 100;\nconst boundary = boxSize * 0.5;\nconst colorSet = [\n  0x8be9fd,\n  0x50fa7b,\n  0xffb86c,\n  0xff79c6,\n  0xbd93f9,\n  0xff5555,\n  0xf1fa8c,\n];\nlet cube;\nconst particles = [];\n\nclass Particle {\n  constructor(x, y, z, dx, dy, dz, radius, color, mass) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.velocity = {\n      x: dx,\n      y: dy,\n      z: dz,\n    };\n    this.radius = radius;\n    this.color = color;\n    this.mass = mass;\n    this.opacity = 0;\n\n    const geometry = new THREE.SphereGeometry(radius);\n    const material = new THREE.MeshBasicMaterial({color: color});\n    this.mesh = new THREE.Mesh(geometry, material);\n    this.mesh.position.set(this.x, this.y, this.z);\n  }\n\n  update(particles) {\n    // check collided\n    particles.forEach(particle => {\n      if (this === particle) {\n        return;\n      }\n\n      if (!this.isCollided(particle)) {\n        return;\n      }\n\n      const temp = this.velocity;\n      this.velocity = particle.velocity;\n      particle.velocity = temp;\n    });\n\n    this.x += this.velocity.x;\n    this.y += this.velocity.y;\n    this.z += this.velocity.z;\n\n    if (\n      this.x + this.radius >= boundary ||\n      this.x - this.radius <= -boundary\n    ) {\n      this.velocity.x *= -1;\n    }\n\n    if (\n      this.y + this.radius >= boundary ||\n      this.y - this.radius <= -boundary\n    ) {\n      this.velocity.y *= -1;\n    }\n\n    if (\n      this.z + this.radius >= boundary ||\n      this.z - this.radius <= -boundary\n    ) {\n      this.velocity.z *= -1;\n    }\n\n    if (this.x - this.radius < -boundary) {\n      this.x = this.radius\n    }\n\n    if (this.y - this.radius < -boundary) {\n      this.y = this.radius\n    }\n\n    if (this.z - this.radius < -boundary) {\n      this.z = this.radius\n    }\n\n    if (this.x + this.radius > boundary) {\n      this.x = boundary - this.radius;\n    }\n\n    if (this.y + this.radius > boundary) {\n      this.y = boundary - this.radius;\n    }\n\n    if (this.z + this.radius > boundary) {\n      this.z = boundary - this.radius;\n    }\n\n    this.mesh.position.set(this.x, this.y, this.z);\n  }\n\n  isCollided(particle) {\n    const x = this.x - particle.x;\n    const y = this.y - particle.y;\n    const z = this.z - particle.z;\n    return (Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2)) <= Math.pow((this.radius + particle.radius), 2);\n  }\n}\n\ninit();\nanimate();\n\nfunction init() {\n  container = document.getElementById('container');\n  width = container.clientWidth;\n  height = container.clientHeight;\n\n  // scene\n  scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x282a36);\n\n  // camera\n  camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);\n  camera.position.set(50, 80, 130);\n  camera.lookAt(0, 0, 0);\n\n  // helper\n  const grid = new THREE.GridHelper(200, 20);\n  scene.add(grid);\n\n  const axes = new THREE.AxesHelper(100);\n  axes.position.set(0, 0, 0);\n  scene.add(axes);\n\n  // renderer\n  renderer = new THREE.WebGLRenderer({antialias: true});\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(width, height);\n  container.appendChild(renderer.domElement);\n\n  // controls\n  const controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.screenSpacePanning = true;\n\n  draw();\n\n  window.addEventListener('resize', onWindowResize, false);\n}\n\nfunction onWindowResize() {\n  width = container.clientWidth;\n  height = container.clientHeight;\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n  renderer.setSize(width, height);\n}\n\nfunction animate() {\n  requestAnimationFrame(animate);\n  render();\n}\n\nfunction render() {\n  renderer.render(scene, camera);\n  particles.forEach(particle => particle.update(particles));\n}\n\nfunction draw() {\n  const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);\n  const material = new THREE.MeshBasicMaterial({color: 0xfffffff, opacity: 0.2, transparent: true});\n  const wireframe = new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true});\n  cube = THREE.SceneUtils.createMultiMaterialObject(geometry, [material, wireframe]);\n  scene.add(cube);\n\n  let cnt = 0;\n  for (let i = 0; i < 100; i++) {\n    const radius = randomInt(1, 5);\n    const x = randomInt(-boundary + radius, boundary - radius);\n    const dx = randomInt(-0.5, 0.5);\n    const y = randomInt(-boundary + radius, boundary - radius);\n    const dy = randomInt(-0.5, 0.5);\n    const z = randomInt(-boundary + radius, boundary - radius);\n    const dz = randomInt(-0.5, 0.5);\n    const color = colorSet[randomInt(0, colorSet.length)];\n\n    const particle = new Particle(x, y, z, dx, dy, dz, radius, color, 1);\n\n    if (particles.some(p => p.isCollided(particle))) {\n      cnt += 1;\n\n      if (cnt > 100) {\n        continue;\n      }\n\n      i -= 1;\n    } else {\n      cnt = 0;\n      particles.push(particle);\n      scene.add(particle.mesh);\n    }\n  }\n}\n"],"sourceRoot":""}