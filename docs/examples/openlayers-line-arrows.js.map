{"version":3,"sources":["webpack:///./openlayers-line-arrows.js"],"names":["const","raster","ol","layer","Tile","source","OSM","Vector","vector","style","feature","geometry","getGeometry","styles","Style","stroke","Stroke","color","width","step","map","Math","abs","getCoordinateFromPixel","getCoordinateStepFromPixel","extent","getView","calculateExtent","getSize","prev","segment","arrows","forEachSegment","start","end","point","dx","dy","rotation","atan2","distance","sqrt","fracStep","prevFrac","push","geom","Point","image","Circle","radius","fill","Fill","let","frac","interpolate","containsCoordinate","Icon","src","anchor","rotateWithView","lastDx","lastDy","lastDistance","console","log","Map","layers","target","view","View","center","zoom","a","b","addInteraction","interaction","Draw","type"],"mappings":"2EAAAA,IAAMC,EAAS,IAAIC,GAAGC,MAAMC,MAC1BC,OAAQ,IAAIH,GAAGG,OAAOC,MAGlBD,EAAS,IAAIH,GAAGG,OAAOE,OAgGvBC,EAAS,IAAIN,GAAGC,MAAMI,QAC1BF,OAAQA,EACRI,MAhGoB,SAASC,GAC7BV,IAAMW,EAAWD,EAAQE,cACnBC,GAEJ,IAAIX,GAAGO,MAAMK,OACXC,OAAQ,IAAIb,GAAGO,MAAMO,QACnBC,MAAO,UACPC,MAAO,OAKPC,EA4GR,SAAoCC,EAAKD,GACvC,OAAOE,KAAKC,IAAIF,EAAIG,wBAAwBJ,EAAK,IAAI,GAAKC,EAAIG,wBAAwB,EAAE,IAAI,IA7G/EC,CAA2BJ,EAAK,IACvCK,EAASL,EAAIM,UAAUC,gBAAgBP,EAAIQ,WAE7CC,EAAO,EACPC,EAAU,EACVC,EAAS,EA2Eb,OA1EApB,EAASqB,eAAe,SAASC,EAAOC,GACtCJ,IAEA9B,IAQImC,EAREC,EAAKF,EAAI,GAAKD,EAAM,GACpBI,EAAKH,EAAI,GAAKD,EAAM,GACpBK,EAAWjB,KAAKkB,MAAMF,EAAID,GAG1BI,EAAWnB,KAAKoB,KAAML,EAAGA,EAAOC,EAAGA,GACnCK,EAAWvB,EAAOqB,EAClBG,EAAWd,EAAOW,EAGxB3B,EAAO+B,KAAK,IAAI1C,GAAGO,MAAMK,OACvBH,SAAU,IAAIT,GAAG2C,KAAKC,MAAMZ,GAC5Ba,MAAO,IAAI7C,GAAGO,MAAMuC,QAClBC,OAAQ,EACRC,KAAM,IAAIhD,GAAGO,MAAM0C,MACjBlC,MAAO,iBAKb,IAAImC,IAAIC,EAAOV,EAAUU,GAAQ,EAAGA,GAAQX,EAC1CP,EAAQmB,EAAYrB,EAAOC,EAAKmB,GAE3BnD,GAAGuB,OAAO8B,mBAAmB9B,EAAQU,KAG1CJ,IAEAlB,EAAO+B,KAAK,IAAI1C,GAAGO,MAAMK,OACvBH,SAAU,IAAIT,GAAG2C,KAAKC,MAAMX,GAC5BY,MAAO,IAAI7C,GAAGO,MAAM+C,MAClBC,IAAK,qBACLC,QAAS,IAAM,IACfC,gBAAgB,EAChBrB,UAAWA,QAKjB,GAAIH,EAAO,CACTnC,IAAM4D,EAAS1B,EAAI,GAAKC,EAAM,GACxB0B,EAAS3B,EAAI,GAAKC,EAAM,GACxB2B,EAAezC,KAAKoB,KAAMmB,EAAOA,EAAWC,EAAOA,GAGvDhC,EADEiC,EAAe,EACV3C,EAAO2C,EAEP,OAGTjC,GAAQW,EAAWrB,IAGvB4C,QAAQC,IAAIlC,EAASC,GAkBdlB,KAOHO,EAAM,IAAIlB,GAAG+D,KACjBC,QAASjE,EAAQO,GACjB2D,OAAQ,MACRC,KAAM,IAAIlE,GAAGmE,MACXC,SAAU,KAAU,MACpBC,KAAM,MASV,SAASjB,EAAYkB,EAAGC,EAAGpB,GAIzB,OAFWmB,EAAE,IAAIC,EAAE,GAAGD,EAAE,IAAInB,EACjBmB,EAAE,IAAIC,EAAE,GAAGD,EAAE,IAAInB,GAR9BjC,EAAIsD,eAAe,IAAIxE,GAAGyE,YAAYC,MACpCvE,OAAQA,EACRwE,KAAM","file":"openlayers-line-arrows.js","sourcesContent":["const raster = new ol.layer.Tile({\n  source: new ol.source.OSM()\n});\n\nconst source = new ol.source.Vector();\n\nconst styleFunction = function(feature) {\n  const geometry = feature.getGeometry();\n  const styles = [\n    // linestring\n    new ol.style.Style({\n      stroke: new ol.style.Stroke({\n        color: '#ffffff',\n        width: 2\n      })\n    })\n  ];\n\n  const step = getCoordinateStepFromPixel(map, 10);\n  const extent = map.getView().calculateExtent(map.getSize());\n\n  let prev = 0;\n  let segment = 0;\n  let arrows = 0;\n  geometry.forEachSegment(function(start, end) {\n    segment++;\n\n    const dx = end[0] - start[0];\n    const dy = end[1] - start[1];\n    const rotation = Math.atan2(dy, dx);\n\n    // arrows\n    const distance = Math.sqrt((dx*dx) + (dy*dy));\n    const fracStep = step / distance;\n    const prevFrac = prev / distance;\n    let point;\n\n    styles.push(new ol.style.Style({\n      geometry: new ol.geom.Point(end),\n      image: new ol.style.Circle({\n        radius: 3,\n        fill: new ol.style.Fill({\n          color: '#0ff000'\n        })\n      })\n    }));\n\n    for(let frac = prevFrac; frac <= 1; frac += fracStep) {\n      point = interpolate(start, end, frac);\n\n      if (!ol.extent.containsCoordinate(extent, point)) {\n        continue;\n      }\n      arrows++;\n\n      styles.push(new ol.style.Style({\n        geometry: new ol.geom.Point(point),\n        image: new ol.style.Icon({\n          src: 'data/img/arrow.png',\n          anchor: [0.75, 0.5],\n          rotateWithView: true,\n          rotation: -rotation\n        })\n      }));\n    }\n\n    if (point) {\n      const lastDx = end[0] - point[0];\n      const lastDy = end[1] - point[1];\n      const lastDistance = Math.sqrt((lastDx*lastDx) + (lastDy*lastDy));\n\n      if (lastDistance > 0) {\n        prev = step - lastDistance;\n      } else {\n        prev = 0;\n      }\n    } else {\n      prev += distance - step;\n    }\n  });\n  console.log(segment, arrows);\n\n  // geometry.forEachSegment(function(start, end) {\n  //     const dx = end[0] - start[0];\n  //     const dy = end[1] - start[1];\n  //     const rotation = Math.atan2(dy, dx);\n  //     // arrows\n  //     styles.push(new ol.style.Style({\n  //         geometry: new ol.geom.Point(end),\n  //         image: new ol.style.Icon({\n  //             src: 'arrow2.png',\n  //             anchor: [0.75, 0.5],\n  //             rotateWithView: true,\n  //             rotation: -rotation\n  //         })\n  //     }));\n  // });\n\n  return styles;\n};\nconst vector = new ol.layer.Vector({\n  source: source,\n  style: styleFunction\n});\n\nconst map = new ol.Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new ol.View({\n    center: [-11000000, 4600000],\n    zoom: 4\n  })\n});\n\nmap.addInteraction(new ol.interaction.Draw({\n  source: source,\n  type: 'LineString'\n}));\n\nfunction interpolate(a, b, frac) // points A and B, frac between 0 and 1\n{\n  const nx = a[0]+(b[0]-a[0])*frac;\n  const ny = a[1]+(b[1]-a[1])*frac;\n  return [nx, ny];\n}\n\nfunction getCoordinateStepFromPixel(map, step) {\n  return Math.abs(map.getCoordinateFromPixel([step,0])[0] - map.getCoordinateFromPixel([0,0])[0]);\n}\n"],"sourceRoot":""}