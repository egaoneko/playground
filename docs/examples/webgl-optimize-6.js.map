{"version":3,"sources":["webpack:///./webgl-optimize-6.js"],"names":["let","gl","canvas","container","glProgram","fragmentShader","vertexShader","vertexPositionAttribute","vertexNormalAttribute","vertexTexCoordAttribute","trianglesInterleavedBuffers","vertexIndexBuffers","spherePositions","currentTime","texture","textureImage","textureFilename","textureAtlasAreas","pMatrix","mat4","create","mvMatrix","normalMatrix","mat3","unit_sphere","num_per_batch","batches","paused","SpherePosition","this","x_offset_orig","Math","random","y_offset_orig","z_offset_orig","x_offset","y_offset","z_offset","x_angle","y_angle","z_angle","angle","radius","i","push","makeShader","source","type","const","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","window","addEventListener","document","querySelector","width","clientWidth","height","clientHeight","getContext","e","console","error","vsSource","fsSource","VERTEX_SHADER","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","initShaders","latitudeBands","longitudeBands","vertices","uvs","latNumber","theta","PI","sinTheta","sin","cosTheta","cos","longNumber","phi","sinPhi","cosPhi","x","y","z","u","v","calculateUnitSpherePoints","interleavedData","indexData","j","mesh_number","active_num","tex_start_x","tex_start_y","tex_scale_x","tex_scale_y","first","second","vertex","uv","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","itemSize","numItems","length","ELEMENT_ARRAY_BUFFER","Uint16Array","STREAM_DRAW","setupSphereData","pMatrixUniform","getUniformLocation","mvMatrixUniform","normalMatrixUniform","samplerUniform","cosTimeUniform","sinTimeUniform","Image","onload","activeTexture","TEXTURE0","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","generateMipmap","isTexture","src","viewport","perspective","uniformMatrix4fv","getAttribLocation","enableVertexAttribArray","identity","translate","invertedMatrix","fromMat4","invert","transpose","uniformMatrix3fv","animLoop","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","DEPTH_TEST","uniform1f","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawElements","TRIANGLES","UNSIGNED_SHORT","drawScene","requestAnimationFrame","evt","keyCode"],"mappings":"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","file":"webgl-optimize-6.js","sourcesContent":["let gl = null;\nlet canvas = null;\nlet container = null;\nlet glProgram = null;\nlet fragmentShader = null;\nlet vertexShader = null;\n\nlet vertexPositionAttribute = null;\nlet vertexNormalAttribute = null;\nlet vertexTexCoordAttribute = null;\nconst trianglesInterleavedBuffers = [];\nconst vertexIndexBuffers = [];\n\nconst spherePositions = [];\nlet currentTime = 0.0;\n\nlet texture = null;\nlet textureImage = null;\nlet textureFilename = \"texture_atlas.jpg\";\n// x_offset, y_offset, x_scale, y_scale\nconst textureAtlasAreas = [\n  [0.0, 0.0, 0.5, 0.5], //moon\n  [0.5, 0.0, 0.5, 0.5], //sun\n  [0.0, 0.5, 0.25, 0.25], //saturn\n  [0.0, 0.75, 0.25, 0.25], //jupiter\n  [0.5, 0.5, 0.25, 0.25], //earth\n  [0.5, 0.75, 0.25, 0.25] //mars\n];\nconst texture_directory = 'data/img/';\n\ntextureFilename = texture_directory + textureFilename;\n\nlet pMatrix = mat4.create();\nlet mvMatrix = mat4.create();\nlet normalMatrix = mat3.create();\n\nlet unit_sphere = null;\n\nconst num_spheres = 20000;\nconst num_per_batch = 250;\nconst batches = num_spheres / num_per_batch;\n\nlet paused = false;\n\nclass SpherePosition {\n  constructor() {\n    this.x_offset_orig = 10.0 - Math.random() * 20.0;\n    this.y_offset_orig = 10.0 - Math.random() * 20.0;\n    this.z_offset_orig = -25.0 + Math.random() * 12.0;\n\n    this.x_offset = this.x_offset_orig;\n    this.y_offset = this.y_offset_orig;\n    this.z_offset = this.z_offset_orig;\n\n    this.x_angle = Math.random() * 360;\n    this.y_angle = Math.random() * 360;\n    this.z_angle = Math.random() * 360;\n    this.angle = 0.005;\n    this.radius = 0.1 + Math.random() * .2;\n  }\n}\n\nfor (let i = 0; i < num_spheres; ++i) {\n  spherePositions.push(new SpherePosition());\n}\n\nwindow.addEventListener('load', initWebGL);\ndocument.addEventListener('keyup', (evt) => {\n  switch (evt.keyCode) {\n    case 80: // 'p'\n      paused = !paused;\n      break;\n  }\n});\n\nfunction initWebGL() {\n  canvas = document.querySelector('#canvas');\n  container = document.querySelector('#container');\n  canvas.width = container.clientWidth;\n  canvas.height = container.clientHeight;\n\n  try {\n    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  } catch (e) {\n    console.error(e);\n  }\n\n  if (gl) {\n    initShaders();\n\n    setupSphereData();\n\n    getMatrixUniforms();\n    loadTexture();\n\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);\n    gl.uniformMatrix4fv(glProgram.pMatrixUniform, false, pMatrix);\n    vertexPositionAttribute = gl.getAttribLocation(glProgram, 'aVertexPosition');\n    vertexNormalAttribute = gl.getAttribLocation(glProgram, 'aVertexNormal');\n    vertexTexCoordAttribute = gl.getAttribLocation(glProgram, 'aVertexTexCoord');\n    gl.enableVertexAttribArray(vertexPositionAttribute);\n    gl.enableVertexAttribArray(vertexNormalAttribute);\n    gl.enableVertexAttribArray(vertexTexCoordAttribute);\n\n    mat4.identity(mvMatrix);\n    mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);\n    mat4.identity(normalMatrix);\n\n    const invertedMatrix = mat3.create();\n    mat3.fromMat4(invertedMatrix, mvMatrix);\n    mat3.invert(normalMatrix, invertedMatrix);\n    mat3.transpose(normalMatrix, normalMatrix);\n\n    setMatrixUniforms();\n\n    (function animLoop() {\n\n      if (!paused) {\n        setupWebGL();\n        drawScene();\n      }\n\n      requestAnimationFrame(animLoop);\n    })();\n  }\n}\n\nfunction setupWebGL() {\n  // set the clear color to a shade of green\n  gl.clearColor(0.1, 0.5, 0.1, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.enable(gl.DEPTH_TEST);\n}\n\nfunction initShaders() {\n  // get shader source\n  const vsSource = vertexShaderSource();\n  const fsSource = fragmentShaderSource();\n\n  // compile shaders\n  vertexShader = makeShader(vsSource, gl.VERTEX_SHADER);\n  fragmentShader = makeShader(fsSource, gl.FRAGMENT_SHADER);\n\n  // create program\n  glProgram = gl.createProgram();\n\n  // attach and link shaders to the program\n  gl.attachShader(glProgram, vertexShader);\n  gl.attachShader(glProgram, fragmentShader);\n  gl.linkProgram(glProgram);\n\n  if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n    alert('Unable to initialize the shader program.');\n  }\n\n  // use program\n  gl.useProgram(glProgram);\n}\n\nfunction makeShader(source, type) {\n  // compile the shader\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);\n  }\n\n  return shader;\n}\n\nfunction vertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexNormal;\n    attribute vec2 aVertexTexCoord;\n    \n    uniform mat3 uNormalMatrix;\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n    uniform float uCosTime;\n    uniform float uSinTime;\n    \n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    void main(void) {\n      vec3 modifiedPosition = vec3(uCosTime + aVertexPosition.x, uSinTime+aVertexPosition.y, aVertexPosition.z + 4.0*uSinTime );\n      gl_Position = uPMatrix * uMVMatrix * vec4(modifiedPosition, 1.0);\n      vTextureCoord = aVertexTexCoord;\n      \n      vec3 pointLightPosition = vec3(1.0,2.0,-1.0);\n      vec3 pointLightDirection = normalize(vec3(pointLightPosition.xyz - modifiedPosition));\n      \n      vec3 L = vec3(uPMatrix * uMVMatrix * vec4(pointLightDirection, 1.0));\n      vec3 N = uNormalMatrix * aVertexNormal;\n      float lambert = max(dot(normalize(N), normalize(L)), 0.0);\n      vLight = 0.1 + lambert;\n    }\n  `;\n}\n\nfunction fragmentShaderSource() {\n  return `\n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    uniform sampler2D uSampler;\n    \n    void main(void) {\n      highp vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.st));\n      gl_FragColor = vec4(textureColor.xyz * vLight, textureColor.a);\n    }\n  `;\n}\n\nfunction drawScene() {\n  gl.uniform1f(glProgram.cosTimeUniform, Math.cos(currentTime));\n  gl.uniform1f(glProgram.sinTimeUniform, Math.sin(currentTime));\n  for (let i = 0; i < batches; ++i) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      3 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      6 * Float32Array.BYTES_PER_ELEMENT);\n    gl.drawElements(gl.TRIANGLES, vertexIndexBuffers[i].numItems, gl.UNSIGNED_SHORT, 0);\n  }\n  currentTime += 0.01;\n}\n\nfunction calculateUnitSpherePoints(latitudeBands, longitudeBands) {\n  // O(n^2) trig operations - costly!\n  unit_sphere = {\n    \"vertices\": [],\n    \"uvs\": []\n  };\n\n  for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n    const theta = latNumber * Math.PI / latitudeBands;\n    const sinTheta = Math.sin(theta);\n    const cosTheta = Math.cos(theta);\n\n    for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n      const phi = longNumber * 2 * Math.PI / longitudeBands;\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n\n      const x = cosPhi * sinTheta;\n      const y = cosTheta;\n      const z = sinPhi * sinTheta;\n      const u = 1 - (longNumber / longitudeBands);\n      const v = latNumber / latitudeBands;\n\n      //position\n      unit_sphere.vertices.push({\"x\": x, \"y\": y, \"z\": z});\n      //texture coordinates\n      unit_sphere.uvs.push({\"u\": u, \"v\": v});\n    }\n  }\n}\n\n//modified from http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere\nfunction setupSphereData() {\n  const latitudeBands = 10;\n  const longitudeBands = 10;\n  calculateUnitSpherePoints(latitudeBands, longitudeBands);\n\n  for (let i = 0; i < batches; ++i) {\n    const interleavedData = [];\n    const indexData = [];\n\n    for (let j = 0; j < num_per_batch; ++j) {\n      const mesh_number = i * num_per_batch + j;\n      const active_num = mesh_number % 6;\n      const tex_start_x = textureAtlasAreas[active_num][0];\n      const tex_start_y = textureAtlasAreas[active_num][1];\n      const tex_scale_x = textureAtlasAreas[active_num][2];\n      const tex_scale_y = textureAtlasAreas[active_num][3];\n\n      const radius = spherePositions[mesh_number].radius;\n\n      for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n        for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n          const first = j * latitudeBands * (longitudeBands + 1) + (latNumber * (longitudeBands + 1)) + longNumber;\n          const second = first + longitudeBands + 1;\n          const vertex = unit_sphere.vertices[latNumber * (longitudeBands + 1) + longNumber];\n          const uv = unit_sphere.uvs[latNumber * (longitudeBands + 1) + longNumber];\n          //position\n          interleavedData.push(radius * vertex.x + spherePositions[mesh_number].x_offset_orig);\n          interleavedData.push(radius * vertex.y + spherePositions[mesh_number].y_offset_orig);\n          interleavedData.push(radius * vertex.z + spherePositions[mesh_number].z_offset_orig);\n          //normal\n          interleavedData.push(vertex.x);\n          interleavedData.push(vertex.y);\n          interleavedData.push(vertex.z);\n\n          //texture coordinates\n          interleavedData.push(uv.u * tex_scale_x + tex_start_x);\n          interleavedData.push(uv.v * tex_scale_y + tex_start_y);\n\n          //indices\n          if ((latNumber < latitudeBands) && (longNumber < longitudeBands)) {\n            indexData.push(first);\n            indexData.push(second);\n            indexData.push(first + 1);\n\n            indexData.push(second);\n            indexData.push(second + 1);\n            indexData.push(first + 1);\n          }\n        }\n      }\n    }\n    trianglesInterleavedBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(interleavedData), gl.STATIC_DRAW);\n    trianglesInterleavedBuffers[i].itemSize = 8;\n    trianglesInterleavedBuffers[i].numItems = interleavedData.length / 8;\n\n    vertexIndexBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffers[i]);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);\n    vertexIndexBuffers[i].itemSize = 3;\n    vertexIndexBuffers[i].numItems = indexData.length;\n  }\n}\n\nfunction getMatrixUniforms() {\n  glProgram.pMatrixUniform = gl.getUniformLocation(glProgram, \"uPMatrix\");\n  glProgram.mvMatrixUniform = gl.getUniformLocation(glProgram, \"uMVMatrix\");\n  glProgram.normalMatrixUniform = gl.getUniformLocation(glProgram, \"uNormalMatrix\");\n  glProgram.samplerUniform = gl.getUniformLocation(glProgram, \"uSampler\");\n  glProgram.cosTimeUniform = gl.getUniformLocation(glProgram, \"uCosTime\");\n  glProgram.sinTimeUniform = gl.getUniformLocation(glProgram, \"uSinTime\");\n}\n\nfunction setMatrixUniforms() {\n  gl.uniformMatrix4fv(glProgram.mvMatrixUniform, false, mvMatrix);\n  gl.uniformMatrix3fv(glProgram.normalMatrixUniform, false, normalMatrix);\n}\n\nfunction loadTexture() {\n  textureImage = new Image();\n  textureImage.onload = function () {\n    setupTexture();\n  };\n  textureImage.src = textureFilename;\n}\n\nfunction setupTexture() {\n  gl.activeTexture(gl.TEXTURE0);\n  texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.generateMipmap(gl.TEXTURE_2D);\n  if (!gl.isTexture(texture)) {\n    console.error(\"Error: Texture is invalid\");\n  }\n}\n"],"sourceRoot":""}