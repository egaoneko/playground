{"version":3,"sources":["webpack:///./three-math02.js"],"names":["let","renderer","scene","camera","width","height","container","props","segments","xMin","xMax","onWindowResize","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","createGraph","A","X","const","xSegments","x","push","generateX","math","transpose","B","multiply","geom","THREE","Geometry","material","PointsMaterial","color","size","sizeAttenuation","console","log","forEach","b","vertices","Vector3","cloud","Points","add","document","getElementById","Scene","background","Color","PerspectiveCamera","position","set","lookAt","grid","GridHelper","axes","AxesHelper","WebGLRenderer","antialias","setPixelRatio","window","devicePixelRatio","appendChild","domElement","OrbitControls","screenSpacePanning","addEventListener","init","animate","requestAnimationFrame","render"],"mappings":"2EACAA,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EAGEC,GACJC,SAAU,IACVC,MAAO,GACPC,KAAM,IA2CR,SAASC,IACPP,EAAQE,EAAUM,YAClBP,EAASC,EAAUO,aACnBV,EAAOW,OAASV,EAAQC,EACxBF,EAAOY,yBACPd,EAASe,QAAQZ,EAAOC,GAsB1B,SAASY,EAAYC,GACnBlB,IAAImB,EAuBN,SAAmBV,EAAMC,EAAMF,GAI7B,IAHAY,IAAMD,KACAE,GAAaX,EAAOD,GAAQD,EAEzBc,EAAIb,EAAMa,GAAKZ,EAAMY,GAAKD,EACjCF,EAAEI,MAAMD,IAGV,OAAOH,EA/BCK,CACNjB,EAAME,KACNF,EAAMG,KACNH,EAAMC,UAGRU,EAAIO,KAAKC,UAAUR,GACnBC,EAAIM,KAAKC,UAAUP,GAEnBC,IAAMO,EAAIF,KAAKC,UAAUD,KAAKG,SAASV,EAAGC,IACpCU,EAAO,IAAIC,MAAMC,SACjBC,EAAW,IAAIF,MAAMG,gBAAgBC,MAAO,SAAUC,KAAM,EAAGC,iBAAiB,IAEtFC,QAAQC,IAAIpB,EAAGC,EAAGQ,GAElBA,EAAEY,QAAO,SAACC,GACRX,EAAKY,SAASlB,KAAK,IAAIO,MAAMY,QAAQF,EAAE,GAAIA,EAAE,GAAIA,EAAE,OAGrDpB,IAAMuB,EAAQ,IAAIb,MAAMc,OAAOf,EAAMG,GACrC9B,EAAM2C,IAAIF,IArFZ,WACErC,EAAYwC,SAASC,eAAe,aACpC3C,EAAQE,EAAUM,YAClBP,EAASC,EAAUO,cAGnBX,EAAQ,IAAI4B,MAAMkB,OACZC,WAAa,IAAInB,MAAMoB,MAAM,IAGnC/C,EAAS,IAAI2B,MAAMqB,kBAAkB,GAAI/C,EAAQC,EAAQ,EAAG,MACrD+C,SAASC,IAAI,GAAI,GAAI,KAC5BlD,EAAOmD,OAAO,EAAG,EAAG,GAGpBlC,IAAMmC,EAAO,IAAIzB,MAAM0B,WAAW,IAAK,IACvCtD,EAAM2C,IAAIU,GAEVnC,IAAMqC,EAAO,IAAI3B,MAAM4B,WAAW,KAClCD,EAAKL,SAASC,IAAI,EAAG,EAAG,GACxBnD,EAAM2C,IAAIY,IAGVxD,EAAW,IAAI6B,MAAM6B,eAAeC,WAAW,KACtCC,cAAcC,OAAOC,kBAC9B9D,EAASe,QAAQZ,EAAOC,GACxBC,EAAU0D,YAAY/D,EAASgE,YAGd,IAAInC,MAAMoC,cAAc/D,EAAQF,EAASgE,YACjDE,oBAAqB,EAyB9BlD,IACG,GAAI,EAAG,KAGVA,IACG,EAAG,EAAG,KA1BT6C,OAAOM,iBAAiB,SAAUzD,GAAgB,GArCpD0D,GAgDA,SAASC,IACPC,sBAAsBD,GAKtBrE,EAASuE,OAAOtE,EAAOC,GArDzBmE","file":"three-math02.js","sourcesContent":["// three\nlet renderer;\nlet scene;\nlet camera;\nlet width;\nlet height;\nlet container;\n\n// math\nconst props = {\n  segments: 100,\n  xMin: -25,\n  xMax: 25,\n};\n\ninit();\nanimate();\n\nfunction init() {\n  container = document.getElementById('container');\n  width = container.clientWidth;\n  height = container.clientHeight;\n\n  // scene\n  scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x000000);\n\n  // camera\n  camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);\n  camera.position.set(50, 80, 130);\n  camera.lookAt(0, 0, 0);\n\n  // helper\n  const grid = new THREE.GridHelper(200, 20);\n  scene.add(grid);\n\n  const axes = new THREE.AxesHelper(100);\n  axes.position.set(0, 0, 0);\n  scene.add(axes);\n\n  // renderer\n  renderer = new THREE.WebGLRenderer({antialias: true});\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(width, height);\n  container.appendChild(renderer.domElement);\n\n  // controls\n  const controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.screenSpacePanning = true;\n\n  draw();\n\n  window.addEventListener('resize', onWindowResize, false);\n}\n\nfunction onWindowResize() {\n  width = container.clientWidth;\n  height = container.clientHeight;\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n  renderer.setSize(width, height);\n}\n\nfunction animate() {\n  requestAnimationFrame(animate);\n  render();\n}\n\nfunction render() {\n  renderer.render(scene, camera);\n}\n\nfunction draw() {\n  createGraph([\n    [4, -1, 1]\n  ]);\n\n  createGraph([\n    [0, 1, 1]\n  ]);\n}\n\nfunction createGraph(A) {\n  let X = generateX(\n    props.xMin,\n    props.xMax,\n    props.segments\n  );\n\n  A = math.transpose(A);\n  X = math.transpose(X);\n\n  const B = math.transpose(math.multiply(A, X));\n  const geom = new THREE.Geometry();\n  const material = new THREE.PointsMaterial({color: 0xffff77, size: 2, sizeAttenuation: false});\n\n  console.log(A, X, B);\n\n  B.forEach(b => {\n    geom.vertices.push(new THREE.Vector3(b[0], b[1], b[2]));\n  });\n\n  const cloud = new THREE.Points(geom, material);\n  scene.add(cloud)\n}\n\nfunction generateX(xMin, xMax, segments) {\n  const X = [];\n  const xSegments = (xMax - xMin) / segments;\n\n  for (let x = xMin; x <= xMax; x += xSegments) {\n    X.push([x]);\n  }\n\n  return X;\n}\n"],"sourceRoot":""}