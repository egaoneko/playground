{"version":3,"sources":["webpack:///./leaflet-poi.js"],"names":["const","map","L","setView","tileLayer","subdomains","attribution","minZoom","maxZoom","attributionControl","setPosition","zoomControl","addLayer","on","Array","from","document","getElementsByClassName","forEach","tile","style","height","clientHeight","width","clientWidth","getJSON","url","successHandler","errorHandler","xhr","XMLHttpRequest","ActiveXObject","open","onreadystatechange","let","status","data","readyState","JSON","parse","responseText","send","loader","PIXI","loaders","Loader","load","resources","textures","plane","texture","circle","bicycle","focusTextures","focusPlane","focusCircle","focusBicycle","markers","legend","querySelector","legendContent","prevZoom","firstDraw","markerSprites","colorScale","d3","scaleLinear","domain","range","frame","focus","pixiContainer","Container","doubleBuffering","test","navigator","userAgent","window","MSStream","pixiOverlay","utils","zoom","getMap","getZoom","cancelAnimationFrame","container","getContainer","renderer","getRenderer","project","latLngToLayerPoint","scale","getScale","invScale","marker","coords","latitude","longitude","index","Math","floor","random","length","markerSprite","Sprite","textureIndex","x0","x","y0","y","anchor","set","tint","color","avancement","rgb","r","g","b","addChild","push","city","label","quadTrees","z","getMinZoom","getMaxZoom","rInit","solveCollision","r0","e","redraw","DomUtil","addClass","innerHTML","findMarker","latlng","removeClass","render","self","this","Util","throttle","_container","ll","layerPoint","quadTree","rMax","found","visit","quad","x1","y1","x2","y2","dx","dy","position","cache","currentX","currentY","targetX","targetY","currentScale","targetScale","start","delta","requestAnimationFrame","animate","timestamp","progress","lambda","destroyInteractionManager","addTo","circles","opts","tree","quadtree","d","xp","yp","undefined","extent","xMin","xMax","yMin","yMax","fixCollision","node","l","c1","c2","lambda1","lambda2","u1","u2","sqrt","r1","r2","alpha","theta","PI","cos","sin","console","log","next","collide","max","add","ret","rMax2","addEventListener"],"mappings":"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","file":"leaflet-poi.js","sourcesContent":["const map = L.map('map').setView([37.49229399862877, -96.94335937500001], 4);\nconst tileLayer = L.tileLayer('//stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', {\n  subdomains: 'abcd',\n  attribution: 'Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, under <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a>. Data by <a href=\"http://openstreetmap.org\">OpenStreetMap</a>, under <a href=\"http://www.openstreetmap.org/copyright\">ODbL</a>.',\n  minZoom: 4,\n  maxZoom: 18\n});\nmap.attributionControl.setPosition('bottomleft');\nmap.zoomControl.setPosition('bottomright');\n\nmap.addLayer(tileLayer);\n\ntileLayer.on('load', () => {\n  Array.from(document.getElementsByClassName('leaflet-tile')).forEach((tile) => {\n    tile.style.height = (tile.clientHeight + 1) + 'px';\n    tile.style.width = (tile.clientWidth + 1) + 'px';\n  });\n});\n\nconst getJSON = function(url, successHandler, errorHandler) {\n  const xhr = typeof XMLHttpRequest != 'undefined'\n    ? new XMLHttpRequest()\n    : new ActiveXObject('Microsoft.XMLHTTP');\n  xhr.open('get', url, true);\n  xhr.onreadystatechange = function() {\n    let status;\n    let data;\n    if (xhr.readyState === 4) {\n      status = xhr.status;\n      if (status === 200) {\n        data = JSON.parse(xhr.responseText);\n        successHandler && successHandler(data);\n      } else {\n        errorHandler && errorHandler(status);\n      }\n    }\n  };\n  xhr.send();\n};\n\nconst loader = new PIXI.loaders.Loader();\nloader\n  .add('plane', 'data/img/leaflet/plane.png')\n  .add('focusPlane', 'data/img/leaflet/focus-plane.png')\n  .add('circle', 'data/img/leaflet/circle.png')\n  .add('focusCircle', 'data/img/leaflet/focus-circle.png')\n  .add('bicycle', 'data/img/leaflet/bicycle.png')\n  .add('focusBicycle', 'data/img/leaflet/focus-bicycle.png');\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  loader.load(load);\n});\n\nfunction load(loader, resources) {\n  const textures = [resources.plane.texture, resources.circle.texture, resources.bicycle.texture];\n  const focusTextures = [resources.focusPlane.texture, resources.focusCircle.texture, resources.focusBicycle.texture];\n  getJSON('data/json/cities.json', function(markers) {\n\n    const legend = document.querySelector('div.legend.geometry');\n    const legendContent = legend.querySelector('.content');\n    const pixiLayer = (() => {\n      let firstDraw = true;\n      let prevZoom;\n      let markerSprites = [];\n      let colorScale = d3.scaleLinear()\n        .domain([0, 50, 100])\n        .range([\"#c6233c\", \"#ffd300\", \"#008000\"]);\n      let frame = null;\n      let focus = null;\n      const pixiContainer = new PIXI.Container();\n      let doubleBuffering = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n      return L.pixiOverlay(function(utils) {\n        const zoom = utils.getMap().getZoom();\n        if (frame) {\n          cancelAnimationFrame(frame);\n          frame = null;\n        }\n        const container = utils.getContainer();\n        const renderer = utils.getRenderer();\n        const project = utils.latLngToLayerPoint;\n        const scale = utils.getScale();\n        const invScale = 1 / scale;\n        if (firstDraw) {\n          prevZoom = zoom;\n          markers.forEach((marker) => {\n            const coords = project([marker.latitude, marker.longitude]);\n            const index = Math.floor(Math.random() * textures.length);\n            const markerSprite = new PIXI.Sprite(textures[index]);\n            markerSprite.textureIndex = index;\n            markerSprite.x0 = coords.x;\n            markerSprite.y0 = coords.y;\n            markerSprite.anchor.set(0.5, 0.5);\n            const tint = d3.color(colorScale(marker.avancement || Math.random() * 100)).rgb();\n            markerSprite.tint = 256 * (tint.r * 256 + tint.g) + tint.b;\n            container.addChild(markerSprite);\n            markerSprites.push(markerSprite);\n            markerSprite.legend = marker.city || marker.label;\n          });\n          const quadTrees = {};\n          for (let z = map.getMinZoom(); z <= map.getMaxZoom(); z++) {\n            const rInit = ((z <= 7) ? 16 : 24) / utils.getScale(z);\n            quadTrees[z] = solveCollision(markerSprites, {r0: rInit, zoom: z});\n          }\n          map.on('click', (e) => {\n            let redraw = false;\n            if (focus) {\n              focus.texture = textures[focus.textureIndex];\n              focus = null;\n              L.DomUtil.addClass(legend, 'hide');\n              legendContent.innerHTML = '';\n              redraw = true;\n            }\n            const marker = findMarker(e.latlng, project, quadTrees, utils);\n            if (marker) {\n              marker.texture = focusTextures[marker.textureIndex];\n              focus = marker;\n              legendContent.innerHTML = marker.legend;\n              L.DomUtil.removeClass(legend, 'hide');\n              redraw = true;\n            }\n            if (redraw) utils.getRenderer().render(container);\n          });\n          let self = this;\n          map.on('mousemove', L.Util.throttle((e) => {\n            const marker = findMarker(e.latlng, project, quadTrees, utils);\n            if (marker) {\n              L.DomUtil.addClass(self._container, 'leaflet-interactive');\n            } else {\n              L.DomUtil.removeClass(self._container, 'leaflet-interactive');\n            }\n          }, 32));\n        }\n        if (firstDraw || prevZoom !== zoom) {\n          markerSprites.forEach((markerSprite) => {\n            const position = markerSprite.cache[zoom];\n            if (firstDraw) {\n              markerSprite.x = position.x;\n              markerSprite.y = position.y;\n              markerSprite.scale.set((position.r * scale < 16) ? position.r / 16 : invScale);\n            } else {\n              markerSprite.currentX = markerSprite.x;\n              markerSprite.currentY = markerSprite.y;\n              markerSprite.targetX = position.x;\n              markerSprite.targetY = position.y;\n              markerSprite.currentScale = markerSprite.scale.x;\n              markerSprite.targetScale = (position.r * scale < 16) ? position.r / 16 : invScale;\n            }\n          });\n        }\n        function findMarker(ll, project, quadTrees, utils) {\n          const layerPoint = project(ll);\n          const quadTree = quadTrees[utils.getMap().getZoom()];\n          let marker;\n          let rMax = quadTree.rMax;\n          let found = false;\n          quadTree.visit((quad, x1, y1, x2, y2) => {\n            if (!quad.length) {\n              const dx = quad.data.x - layerPoint.x;\n              const dy = quad.data.y - layerPoint.y;\n              const r = quad.data.scale.x * 16;\n              if (dx * dx + dy * dy <= r * r) {\n                marker = quad.data;\n                found = true;\n              }\n            }\n            return found || x1 > layerPoint.x + rMax || x2 + rMax < layerPoint.x || y1 > layerPoint.y + rMax || y2 + rMax < layerPoint.y;\n          });\n          return marker;\n        }\n\n        let start = null;\n        const delta = 250;\n        function animate(timestamp) {\n          var progress;\n          if (start === null) start = timestamp;\n          progress = timestamp - start;\n          var lambda = progress / delta;\n          if (lambda > 1) lambda = 1;\n          lambda = lambda * (0.4 + lambda * (2.2 + lambda * -1.6));\n          markerSprites.forEach(function(markerSprite) {\n            markerSprite.x = markerSprite.currentX + lambda * (markerSprite.targetX - markerSprite.currentX);\n            markerSprite.y = markerSprite.currentY + lambda * (markerSprite.targetY - markerSprite.currentY);\n            markerSprite.scale.set(markerSprite.currentScale + lambda * (markerSprite.targetScale - markerSprite.currentScale));\n          });\n          renderer.render(container);\n          if (progress < delta) {\n            frame = requestAnimationFrame(animate);\n          }\n        }\n        if (!firstDraw && prevZoom !== zoom) {\n          frame = requestAnimationFrame(animate);\n        }\n        firstDraw = false;\n        prevZoom = zoom;\n        renderer.render(container);\n      }, pixiContainer, {\n        doubleBuffering: doubleBuffering,\n        destroyInteractionManager: true\n      });\n    })();\n    pixiLayer.addTo(map);\n  });\n}\n\nfunction solveCollision(circles, opts) {\n  opts = opts || {};\n  var tree = d3.quadtree()\n    .x(function(d) {return d.xp;})\n    .y(function(d) {return d.yp;});\n  if (opts.extent !== undefined) tree.extent(opts.extent);\n  var rMax = 0;\n  circles.forEach(function(circle) {\n    circle.xp = circle.x0;\n    circle.yp = circle.y0;\n    if (opts.r0 !== undefined) circle.r0 = opts.r0;\n    circle.r = circle.r0;\n    circle.xMin = circle.x0 - circle.r0;\n    circle.xMax = circle.x0 + circle.r0;\n    circle.yMin = circle.y0 - circle.r0;\n    circle.yMax = circle.y0 + circle.r0;\n\n    function collide(d) {\n      function fixCollision(node) {\n        var x = d.xp - node.xp;\n        var y = d.yp - node.yp;\n        var l = x * x + y * y;\n        var r = d.r + node.r;\n        if (l < r * r) {\n          var c1, c2, lambda1, lambda2, u1, u2;\n          var delta = Math.sqrt(l);\n          if (d.r < node.r) {\n            c1 = node; c2 = d;\n          } else {\n            c1 = d; c2 = node;\n          }\n          var r1 = c1.r;\n          var r2 = c2.r;\n          var alpha = (r1 + r2 + delta) / 4;\n          if (l > 0) {\n            u1 = (c2.xp - c1.xp) / delta;\n            u2 = (c2.yp - c1.yp) / delta;\n          } else {\n            var theta = 2 * Math.PI * Math.random();\n            u1 = Math.cos(theta);\n            u2 = Math.sin(theta);\n          }\n\n          if (r2 >= alpha) {\n            lambda1 = alpha / r1;\n            lambda2 = alpha / r2;\n          } else {\n            lambda1 = (r1 - r2 + delta) / (2 * r1);\n            if (lambda1 > 1) console.log(lambda1);\n            lambda2 = 1;\n          }\n          c1.r *= lambda1;\n          c2.r *= lambda2;\n          c1.xp += (lambda1 - 1) * r1 * u1;\n          c1.yp += (lambda1 - 1) * r1 * u2;\n          c2.xp += (1 - lambda2) * r2 * u1;\n          c2.yp += (1 - lambda2) * r2 * u2;\n          c1.xMin = c1.xp - c1.r;\n          c1.xMax = c1.xp + c1.r;\n          c1.yMin = c1.yp - c1.r;\n          c1.yMax = c1.yp + c1.r;\n          c2.xMin = c2.xp - c2.r;\n          c2.xMax = c2.xp + c2.r;\n          c2.yMin = c2.yp - c2.r;\n          c2.yMax = c2.yp + c2.r;\n        }\n      }\n      return function(quad, x1, y1, x2, y2) {\n        if (!quad.length) {\n          do {\n            if (quad.data != d && d.xMax > quad.data.xMin && d.xMin < quad.data.xMax && d.yMax > quad.data.yMin && d.yMin < quad.data.yMax) {\n              fixCollision(quad.data);\n            }\n          } while (quad = quad.next)\n        }\n        return x1 > d.xMax + rMax || x2 + rMax < d.xMin || y1 > d.yMax + rMax || y2 + rMax < d.yMin;\n      };\n    }\n    tree.visit(collide(circle));\n    rMax = Math.max(rMax, circle.r);\n    tree.add(circle);\n  });\n  if (opts.zoom !== undefined) {\n    circles.forEach(function(circle) {\n      circle.cache = circle.cache || {};\n      circle.cache[opts.zoom] = {\n        x: circle.xp,\n        y: circle.yp,\n        r: circle.r\n      };\n    });\n  }\n  var ret = d3.quadtree()\n    .x(function(d) {return d.xp;})\n    .y(function(d) {return d.yp;});\n  var rMax2 = 0;\n  circles.forEach(function(circle) {\n    ret.add(circle);\n    rMax2 = Math.max(rMax2, circle.r);\n  })\n  ret.rMax = rMax2;\n  return ret;\n}\n"],"sourceRoot":""}