{"version":3,"sources":["webpack:///./webgl-optimize-5.js"],"names":["let","gl","canvas","container","glProgram","fragmentShader","vertexShader","vertexPositionAttribute","vertexNormalAttribute","vertexTexCoordAttribute","trianglesInterleavedBuffers","vertexIndexBuffers","spherePositions","currentTime","texture","textureImage","textureFilename","textureAtlasAreas","pMatrix","mat4","create","mvMatrix","normalMatrix","mat3","num_per_batch","batches","paused","SpherePosition","this","x_offset_orig","Math","random","y_offset_orig","z_offset_orig","x_offset","y_offset","z_offset","x_angle","y_angle","z_angle","angle","radius","i","push","makeShader","source","type","const","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","window","addEventListener","document","querySelector","width","clientWidth","height","clientHeight","getContext","e","console","error","vsSource","fsSource","VERTEX_SHADER","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","initShaders","interleavedData","indexData","j","mesh_number","active_num","tex_start_x","tex_start_y","tex_scale_x","tex_scale_y","latNumber","theta","PI","sinTheta","sin","cosTheta","cos","longNumber","phi","sinPhi","cosPhi","x","y","z","u","v","first","second","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","itemSize","numItems","length","ELEMENT_ARRAY_BUFFER","Uint16Array","STREAM_DRAW","setupSphereData","pMatrixUniform","getUniformLocation","mvMatrixUniform","normalMatrixUniform","samplerUniform","cosTimeUniform","sinTimeUniform","Image","onload","activeTexture","TEXTURE0","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","generateMipmap","isTexture","src","viewport","perspective","uniformMatrix4fv","getAttribLocation","enableVertexAttribArray","identity","translate","invertedMatrix","fromMat4","invert","transpose","uniformMatrix3fv","animLoop","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","DEPTH_TEST","uniform1f","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawElements","TRIANGLES","UNSIGNED_SHORT","drawScene","requestAnimationFrame","evt","keyCode"],"mappings":"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","file":"webgl-optimize-5.js","sourcesContent":["let gl = null;\nlet canvas = null;\nlet container = null;\nlet glProgram = null;\nlet fragmentShader = null;\nlet vertexShader = null;\n\nlet vertexPositionAttribute = null;\nlet vertexNormalAttribute = null;\nlet vertexTexCoordAttribute = null;\nconst trianglesInterleavedBuffers = [];\nconst vertexIndexBuffers = [];\n\nconst spherePositions = [];\nlet currentTime = 0.0;\n\nlet texture = null;\nlet textureImage = null;\nlet textureFilename = \"texture_atlas.jpg\";\n// x_offset, y_offset, x_scale, y_scale\nconst textureAtlasAreas = [\n  [0.0, 0.0, 0.5, 0.5], //moon\n  [0.5, 0.0, 0.5, 0.5], //sun\n  [0.0, 0.5, 0.25, 0.25], //saturn\n  [0.0, 0.75, 0.25, 0.25], //jupiter\n  [0.5, 0.5, 0.25, 0.25], //earth\n  [0.5, 0.75, 0.25, 0.25] //mars\n];\nconst texture_directory = 'data/img/';\n\ntextureFilename = texture_directory + textureFilename;\n\nlet pMatrix = mat4.create();\nlet mvMatrix = mat4.create();\nlet normalMatrix = mat3.create();\n\nconst num_spheres = 20000;\nconst num_per_batch = 250;\nconst batches = num_spheres / num_per_batch;\n\nlet paused = false;\n\nclass SpherePosition {\n  constructor() {\n    this.x_offset_orig = 10.0 - Math.random() * 20.0;\n    this.y_offset_orig = 10.0 - Math.random() * 20.0;\n    this.z_offset_orig = -25.0 + Math.random() * 12.0;\n\n    this.x_offset = this.x_offset_orig;\n    this.y_offset = this.y_offset_orig;\n    this.z_offset = this.z_offset_orig;\n\n    this.x_angle = Math.random() * 360;\n    this.y_angle = Math.random() * 360;\n    this.z_angle = Math.random() * 360;\n    this.angle = 0.005;\n    this.radius = 0.1 + Math.random() * .2;\n  }\n}\n\nfor (let i = 0; i < num_spheres; ++i) {\n  spherePositions.push(new SpherePosition());\n}\n\nwindow.addEventListener('load', initWebGL);\ndocument.addEventListener('keyup', (evt) => {\n  switch (evt.keyCode) {\n    case 80: // 'p'\n      paused = !paused;\n      break;\n  }\n});\n\nfunction initWebGL() {\n  canvas = document.querySelector('#canvas');\n  container = document.querySelector('#container');\n  canvas.width = container.clientWidth;\n  canvas.height = container.clientHeight;\n\n  try {\n    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  } catch (e) {\n    console.error(e);\n  }\n\n  if (gl) {\n    initShaders();\n\n    setupSphereData();\n\n    getMatrixUniforms();\n    loadTexture();\n\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);\n    gl.uniformMatrix4fv(glProgram.pMatrixUniform, false, pMatrix);\n    vertexPositionAttribute = gl.getAttribLocation(glProgram, 'aVertexPosition');\n    vertexNormalAttribute = gl.getAttribLocation(glProgram, 'aVertexNormal');\n    vertexTexCoordAttribute = gl.getAttribLocation(glProgram, 'aVertexTexCoord');\n    gl.enableVertexAttribArray(vertexPositionAttribute);\n    gl.enableVertexAttribArray(vertexNormalAttribute);\n    gl.enableVertexAttribArray(vertexTexCoordAttribute);\n\n    mat4.identity(mvMatrix);\n    mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);\n    mat4.identity(normalMatrix);\n\n    const invertedMatrix = mat3.create();\n    mat3.fromMat4(invertedMatrix, mvMatrix);\n    mat3.invert(normalMatrix, invertedMatrix);\n    mat3.transpose(normalMatrix, normalMatrix);\n\n    setMatrixUniforms();\n\n    (function animLoop() {\n\n      if (!paused) {\n        setupWebGL();\n        drawScene();\n      }\n\n      requestAnimationFrame(animLoop);\n    })();\n  }\n}\n\nfunction setupWebGL() {\n  // set the clear color to a shade of green\n  gl.clearColor(0.1, 0.5, 0.1, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.enable(gl.DEPTH_TEST);\n}\n\nfunction initShaders() {\n  // get shader source\n  const vsSource = vertexShaderSource();\n  const fsSource = fragmentShaderSource();\n\n  // compile shaders\n  vertexShader = makeShader(vsSource, gl.VERTEX_SHADER);\n  fragmentShader = makeShader(fsSource, gl.FRAGMENT_SHADER);\n\n  // create program\n  glProgram = gl.createProgram();\n\n  // attach and link shaders to the program\n  gl.attachShader(glProgram, vertexShader);\n  gl.attachShader(glProgram, fragmentShader);\n  gl.linkProgram(glProgram);\n\n  if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n    alert('Unable to initialize the shader program.');\n  }\n\n  // use program\n  gl.useProgram(glProgram);\n}\n\nfunction makeShader(source, type) {\n  // compile the shader\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);\n  }\n\n  return shader;\n}\n\nfunction vertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexNormal;\n    attribute vec2 aVertexTexCoord;\n    \n    uniform mat3 uNormalMatrix;\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n    uniform float uCosTime;\n    uniform float uSinTime;\n    \n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    void main(void) {\n      vec3 modifiedPosition = vec3(uCosTime + aVertexPosition.x, uSinTime+aVertexPosition.y, aVertexPosition.z + 4.0*uSinTime );\n      gl_Position = uPMatrix * uMVMatrix * vec4(modifiedPosition, 1.0);\n      vTextureCoord = aVertexTexCoord;\n      \n      vec3 pointLightPosition = vec3(1.0,2.0,-1.0);\n      vec3 pointLightDirection = normalize(vec3(pointLightPosition.xyz - modifiedPosition));\n      \n      vec3 L = vec3(uPMatrix * uMVMatrix * vec4(pointLightDirection, 1.0));\n      vec3 N = uNormalMatrix * aVertexNormal;\n      float lambert = max(dot(normalize(N), normalize(L)), 0.0);\n      vLight = 0.1 + lambert;\n    }\n  `;\n}\n\nfunction fragmentShaderSource() {\n  return `\n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    uniform sampler2D uSampler;\n    \n    void main(void) {\n      highp vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.st));\n      gl_FragColor = vec4(textureColor.xyz * vLight, textureColor.a);\n    }\n  `;\n}\n\nfunction drawScene() {\n  gl.uniform1f(glProgram.cosTimeUniform, Math.cos(currentTime));\n  gl.uniform1f(glProgram.sinTimeUniform, Math.sin(currentTime));\n  for (let i = 0; i < batches; ++i) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      3 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      6 * Float32Array.BYTES_PER_ELEMENT);\n    gl.drawElements(gl.TRIANGLES, vertexIndexBuffers[i].numItems, gl.UNSIGNED_SHORT, 0);\n  }\n  currentTime += 0.01;\n}\n\n//modified from http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere\nfunction setupSphereData() {\n  const latitudeBands = 10;\n  const longitudeBands = 10;\n\n  for (let i = 0; i < batches; ++i) {\n    const interleavedData = [];\n    const indexData = [];\n\n    for (let j = 0; j < num_per_batch; ++j) {\n      const mesh_number = i * num_per_batch + j;\n      const active_num = mesh_number % 6;\n      const tex_start_x = textureAtlasAreas[active_num][0];\n      const tex_start_y = textureAtlasAreas[active_num][1];\n      const tex_scale_x = textureAtlasAreas[active_num][2];\n      const tex_scale_y = textureAtlasAreas[active_num][3];\n\n      const radius = spherePositions[mesh_number].radius;\n\n      for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n        const theta = latNumber * Math.PI / latitudeBands;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n\n        for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n          const phi = longNumber * 2 * Math.PI / longitudeBands;\n          const sinPhi = Math.sin(phi);\n          const cosPhi = Math.cos(phi);\n\n          const x = cosPhi * sinTheta;\n          const y = cosTheta;\n          const z = sinPhi * sinTheta;\n          const u = 1 - (longNumber / longitudeBands);\n          const v = latNumber / latitudeBands;\n          const first = j * latitudeBands * (longitudeBands + 1) + (latNumber * (longitudeBands + 1)) + longNumber;\n          const second = first + longitudeBands + 1;\n\n          //position\n          interleavedData.push(radius * x + spherePositions[mesh_number].x_offset_orig);\n          interleavedData.push(radius * y + spherePositions[mesh_number].y_offset_orig);\n          interleavedData.push(radius * z + spherePositions[mesh_number].z_offset_orig);\n          //normal\n          interleavedData.push(x);\n          interleavedData.push(y);\n          interleavedData.push(z);\n\n          //texture coordinates\n          interleavedData.push(u * tex_scale_x + tex_start_x);\n          interleavedData.push(v * tex_scale_y + tex_start_y);\n\n          //indices\n          if ((latNumber < latitudeBands) && (longNumber < longitudeBands)) {\n            indexData.push(first);\n            indexData.push(second);\n            indexData.push(first + 1);\n\n            indexData.push(second);\n            indexData.push(second + 1);\n            indexData.push(first + 1);\n          }\n        }\n      }\n    }\n    trianglesInterleavedBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(interleavedData), gl.STATIC_DRAW);\n    trianglesInterleavedBuffers[i].itemSize = 8;\n    trianglesInterleavedBuffers[i].numItems = interleavedData.length / 8;\n\n    vertexIndexBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffers[i]);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);\n    vertexIndexBuffers[i].itemSize = 3;\n    vertexIndexBuffers[i].numItems = indexData.length;\n  }\n}\n\nfunction getMatrixUniforms() {\n  glProgram.pMatrixUniform = gl.getUniformLocation(glProgram, \"uPMatrix\");\n  glProgram.mvMatrixUniform = gl.getUniformLocation(glProgram, \"uMVMatrix\");\n  glProgram.normalMatrixUniform = gl.getUniformLocation(glProgram, \"uNormalMatrix\");\n  glProgram.samplerUniform = gl.getUniformLocation(glProgram, \"uSampler\");\n  glProgram.cosTimeUniform = gl.getUniformLocation(glProgram, \"uCosTime\");\n  glProgram.sinTimeUniform = gl.getUniformLocation(glProgram, \"uSinTime\");\n}\n\nfunction setMatrixUniforms() {\n  gl.uniformMatrix4fv(glProgram.mvMatrixUniform, false, mvMatrix);\n  gl.uniformMatrix3fv(glProgram.normalMatrixUniform, false, normalMatrix);\n}\n\nfunction loadTexture() {\n  textureImage = new Image();\n  textureImage.onload = function () {\n    setupTexture();\n  };\n  textureImage.src = textureFilename;\n}\n\nfunction setupTexture() {\n  gl.activeTexture(gl.TEXTURE0);\n  texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.generateMipmap(gl.TEXTURE_2D);\n  if (!gl.isTexture(texture)) {\n    console.error(\"Error: Texture is invalid\");\n  }\n}\n"],"sourceRoot":""}