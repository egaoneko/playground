<!DOCTYPE html>
<html lang="en-US">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62717870-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-62717870-1');
    </script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" type="text/css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="./resources/prism/prism.css" type="text/css">
    <link rel="stylesheet" href="./resources/layout-full.css" type="text/css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.7/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-pixi-overlay@1.7.0/L.PixiOverlay.min.js"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
    <link rel="stylesheet" href="leaflet-poi.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default%2CrequestAnimationFrame%2Cfetch%2CElement.prototype.classList%2CURL%2CMap%2CSet%2CPromise%2CObject.values"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js"></script>
    <script
      src="https://code.jquery.com/jquery-2.2.4.min.js"
      integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
      crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <title>Leaflet poi example</title>
  </head>
  <body>
  <header class="navbar dropdown" role="navigation">
    <button type="button" class="btn btn-default dropdown-toggle" id="hamburger" data-toggle="dropdown" aria-label="hamburger" aria-haspopup="true" aria-expanded="false">
      <span class="glyphicon glyphicon glyphicon-align-justify" aria-hidden="true"></span>
    </button>
    <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="hamburger">
      <li><a class="active" href="index.html">Examples</a></li>
      <li><a href="../apidoc">API</a></li>
      <li><a href="https://github.com/egaoneko/playground">Code</a></li>
      <li role="separator" class="divider"></li>
      <li><a href="#" data-toggle="modal" data-target="#flipFlop">Source</a></li>
    </ul>
  </header>
  <div id="container" class="main">
  <div id="map">
    <div class="legend geometry top center hide">
      <div class="wrapper">
        <div class="content"></div>
      </div>
    </div>
  </div>
</div>


  <!-- The modal -->
  <div class="modal fade" id="flipFlop" tabindex="-1" role="dialog" aria-labelledby="modalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
          <h4 class="modal-title" id="modalLabel">Leaflet poi example</h4>
        </div>
        <div class="modal-body">
          <div class="row-fluid">
            <div class="span12">
              <p id="shortdesc">Leaflet poi example.</p>
              <div id="docs"><p>This page&#39;s Leaflet poi example.</p>
</div>
              <p id="tags">Tags: leafelt</p>
            </div>
          </div>

          <div class="row-fluid">
            <div id="source-controls">
              <a id="copy-button" data-clipboard-target="#example-source"><i class="fa fa-clipboard"></i> Copy</a>
              <!-- <a id="codepen-button"><i class="fa fa-codepen"></i> Edit</a> -->
            </div>
            <form method="POST" id="codepen-form" target="_blank" action="https://codepen.io/pen/define/">
              <textarea class="hidden" name="title">Leaflet poi example</textarea>
              <textarea class="hidden" name="description">Leaflet poi example.</textarea>
              <textarea class="hidden" name="js">var map &#x3D; L.map(&#x27;map&#x27;).setView([37.49229399862877, -96.94335937500001], 4);
var tileLayer &#x3D; L.tileLayer(&#x27;//stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png&#x27;, {
  subdomains: &#x27;abcd&#x27;,
  attribution: &#x27;Map tiles by &lt;a href&#x3D;&quot;http://stamen.com&quot;&gt;Stamen Design&lt;/a&gt;, under &lt;a href&#x3D;&quot;http://creativecommons.org/licenses/by/3.0&quot;&gt;CC BY 3.0&lt;/a&gt;. Data by &lt;a href&#x3D;&quot;http://openstreetmap.org&quot;&gt;OpenStreetMap&lt;/a&gt;, under &lt;a href&#x3D;&quot;http://www.openstreetmap.org/copyright&quot;&gt;ODbL&lt;/a&gt;.&#x27;,
  minZoom: 4,
  maxZoom: 18
});
map.attributionControl.setPosition(&#x27;bottomleft&#x27;);
map.zoomControl.setPosition(&#x27;bottomright&#x27;);

map.addLayer(tileLayer);

tileLayer.on(&#x27;load&#x27;, function () {
  Array.from(document.getElementsByClassName(&#x27;leaflet-tile&#x27;)).forEach(function (tile) {
    tile.style.height &#x3D; (tile.clientHeight + 1) + &#x27;px&#x27;;
    tile.style.width &#x3D; (tile.clientWidth + 1) + &#x27;px&#x27;;
  });
});

var getJSON &#x3D; function(url, successHandler, errorHandler) {
  var xhr &#x3D; typeof XMLHttpRequest !&#x3D; &#x27;undefined&#x27;
    ? new XMLHttpRequest()
    : new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);
  xhr.open(&#x27;get&#x27;, url, true);
  xhr.onreadystatechange &#x3D; function() {
    var status;
    var data;
    if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) {
      status &#x3D; xhr.status;
      if (status &#x3D;&#x3D;&#x3D; 200) {
        data &#x3D; JSON.parse(xhr.responseText);
        successHandler &amp;&amp; successHandler(data);
      } else {
        errorHandler &amp;&amp; errorHandler(status);
      }
    }
  };
  xhr.send();
};

var loader &#x3D; new PIXI.loaders.Loader();
loader
  .add(&#x27;plane&#x27;, &#x27;data/img/leaflet/plane.png&#x27;)
  .add(&#x27;focusPlane&#x27;, &#x27;data/img/leaflet/focus-plane.png&#x27;)
  .add(&#x27;circle&#x27;, &#x27;data/img/leaflet/circle.png&#x27;)
  .add(&#x27;focusCircle&#x27;, &#x27;data/img/leaflet/focus-circle.png&#x27;)
  .add(&#x27;bicycle&#x27;, &#x27;data/img/leaflet/bicycle.png&#x27;)
  .add(&#x27;focusBicycle&#x27;, &#x27;data/img/leaflet/focus-bicycle.png&#x27;);
document.addEventListener(&quot;DOMContentLoaded&quot;, function () {
  loader.load(load);
});

function load(loader, resources) {
  var textures &#x3D; [resources.plane.texture, resources.circle.texture, resources.bicycle.texture];
  var focusTextures &#x3D; [resources.focusPlane.texture, resources.focusCircle.texture, resources.focusBicycle.texture];
  getJSON(&#x27;data/json/cities.json&#x27;, function(markers) {

    var legend &#x3D; document.querySelector(&#x27;div.legend.geometry&#x27;);
    var legendContent &#x3D; legend.querySelector(&#x27;.content&#x27;);
    var pixiLayer &#x3D; (function () {
      var firstDraw &#x3D; true;
      var prevZoom;
      var markerSprites &#x3D; [];
      var colorScale &#x3D; d3.scaleLinear()
        .domain([0, 50, 100])
        .range([&quot;#c6233c&quot;, &quot;#ffd300&quot;, &quot;#008000&quot;]);
      var frame &#x3D; null;
      var focus &#x3D; null;
      var pixiContainer &#x3D; new PIXI.Container();
      var doubleBuffering &#x3D; /iPad|iPhone|iPod/.test(navigator.userAgent) &amp;&amp; !window.MSStream;
      return L.pixiOverlay(function(utils) {
        var zoom &#x3D; utils.getMap().getZoom();
        if (frame) {
          cancelAnimationFrame(frame);
          frame &#x3D; null;
        }
        var container &#x3D; utils.getContainer();
        var renderer &#x3D; utils.getRenderer();
        var project &#x3D; utils.latLngToLayerPoint;
        var scale &#x3D; utils.getScale();
        var invScale &#x3D; 1 / scale;
        if (firstDraw) {
          prevZoom &#x3D; zoom;
          markers.forEach(function (marker) {
            var coords &#x3D; project([marker.latitude, marker.longitude]);
            var index &#x3D; Math.floor(Math.random() * textures.length);
            var markerSprite &#x3D; new PIXI.Sprite(textures[index]);
            markerSprite.textureIndex &#x3D; index;
            markerSprite.x0 &#x3D; coords.x;
            markerSprite.y0 &#x3D; coords.y;
            markerSprite.anchor.set(0.5, 0.5);
            var tint &#x3D; d3.color(colorScale(marker.avancement || Math.random() * 100)).rgb();
            markerSprite.tint &#x3D; 256 * (tint.r * 256 + tint.g) + tint.b;
            container.addChild(markerSprite);
            markerSprites.push(markerSprite);
            markerSprite.legend &#x3D; marker.city || marker.label;
          });
          var quadTrees &#x3D; {};
          for (var z &#x3D; map.getMinZoom(); z &lt;&#x3D; map.getMaxZoom(); z++) {
            var rInit &#x3D; ((z &lt;&#x3D; 7) ? 16 : 24) / utils.getScale(z);
            quadTrees[z] &#x3D; solveCollision(markerSprites, {r0: rInit, zoom: z});
          }
          map.on(&#x27;click&#x27;, function (e) {
            var redraw &#x3D; false;
            if (focus) {
              focus.texture &#x3D; textures[focus.textureIndex];
              focus &#x3D; null;
              L.DomUtil.addClass(legend, &#x27;hide&#x27;);
              legendContent.innerHTML &#x3D; &#x27;&#x27;;
              redraw &#x3D; true;
            }
            var marker &#x3D; findMarker(e.latlng, project, quadTrees, utils);
            if (marker) {
              marker.texture &#x3D; focusTextures[marker.textureIndex];
              focus &#x3D; marker;
              legendContent.innerHTML &#x3D; marker.legend;
              L.DomUtil.removeClass(legend, &#x27;hide&#x27;);
              redraw &#x3D; true;
            }
            if (redraw) { utils.getRenderer().render(container); }
          });
          var self &#x3D; this;
          map.on(&#x27;mousemove&#x27;, L.Util.throttle(function (e) {
            var marker &#x3D; findMarker(e.latlng, project, quadTrees, utils);
            if (marker) {
              L.DomUtil.addClass(self._container, &#x27;leaflet-interactive&#x27;);
            } else {
              L.DomUtil.removeClass(self._container, &#x27;leaflet-interactive&#x27;);
            }
          }, 32));
        }
        if (firstDraw || prevZoom !&#x3D;&#x3D; zoom) {
          markerSprites.forEach(function (markerSprite) {
            var position &#x3D; markerSprite.cache[zoom];
            if (firstDraw) {
              markerSprite.x &#x3D; position.x;
              markerSprite.y &#x3D; position.y;
              markerSprite.scale.set((position.r * scale &lt; 16) ? position.r / 16 : invScale);
            } else {
              markerSprite.currentX &#x3D; markerSprite.x;
              markerSprite.currentY &#x3D; markerSprite.y;
              markerSprite.targetX &#x3D; position.x;
              markerSprite.targetY &#x3D; position.y;
              markerSprite.currentScale &#x3D; markerSprite.scale.x;
              markerSprite.targetScale &#x3D; (position.r * scale &lt; 16) ? position.r / 16 : invScale;
            }
          });
        }
        function findMarker(ll, project, quadTrees, utils) {
          var layerPoint &#x3D; project(ll);
          var quadTree &#x3D; quadTrees[utils.getMap().getZoom()];
          var marker;
          var rMax &#x3D; quadTree.rMax;
          var found &#x3D; false;
          quadTree.visit(function (quad, x1, y1, x2, y2) {
            if (!quad.length) {
              var dx &#x3D; quad.data.x - layerPoint.x;
              var dy &#x3D; quad.data.y - layerPoint.y;
              var r &#x3D; quad.data.scale.x * 16;
              if (dx * dx + dy * dy &lt;&#x3D; r * r) {
                marker &#x3D; quad.data;
                found &#x3D; true;
              }
            }
            return found || x1 &gt; layerPoint.x + rMax || x2 + rMax &lt; layerPoint.x || y1 &gt; layerPoint.y + rMax || y2 + rMax &lt; layerPoint.y;
          });
          return marker;
        }

        var start &#x3D; null;
        var delta &#x3D; 250;
        function animate(timestamp) {
          var progress;
          if (start &#x3D;&#x3D;&#x3D; null) { start &#x3D; timestamp; }
          progress &#x3D; timestamp - start;
          var lambda &#x3D; progress / delta;
          if (lambda &gt; 1) { lambda &#x3D; 1; }
          lambda &#x3D; lambda * (0.4 + lambda * (2.2 + lambda * -1.6));
          markerSprites.forEach(function(markerSprite) {
            markerSprite.x &#x3D; markerSprite.currentX + lambda * (markerSprite.targetX - markerSprite.currentX);
            markerSprite.y &#x3D; markerSprite.currentY + lambda * (markerSprite.targetY - markerSprite.currentY);
            markerSprite.scale.set(markerSprite.currentScale + lambda * (markerSprite.targetScale - markerSprite.currentScale));
          });
          renderer.render(container);
          if (progress &lt; delta) {
            frame &#x3D; requestAnimationFrame(animate);
          }
        }
        if (!firstDraw &amp;&amp; prevZoom !&#x3D;&#x3D; zoom) {
          frame &#x3D; requestAnimationFrame(animate);
        }
        firstDraw &#x3D; false;
        prevZoom &#x3D; zoom;
        renderer.render(container);
      }, pixiContainer, {
        doubleBuffering: doubleBuffering,
        destroyInteractionManager: true
      });
    })();
    pixiLayer.addTo(map);
  });
}

function solveCollision(circles, opts) {
  opts &#x3D; opts || {};
  var tree &#x3D; d3.quadtree()
    .x(function(d) {return d.xp;})
    .y(function(d) {return d.yp;});
  if (opts.extent !&#x3D;&#x3D; undefined) { tree.extent(opts.extent); }
  var rMax &#x3D; 0;
  circles.forEach(function(circle) {
    circle.xp &#x3D; circle.x0;
    circle.yp &#x3D; circle.y0;
    if (opts.r0 !&#x3D;&#x3D; undefined) { circle.r0 &#x3D; opts.r0; }
    circle.r &#x3D; circle.r0;
    circle.xMin &#x3D; circle.x0 - circle.r0;
    circle.xMax &#x3D; circle.x0 + circle.r0;
    circle.yMin &#x3D; circle.y0 - circle.r0;
    circle.yMax &#x3D; circle.y0 + circle.r0;

    function collide(d) {
      function fixCollision(node) {
        var x &#x3D; d.xp - node.xp;
        var y &#x3D; d.yp - node.yp;
        var l &#x3D; x * x + y * y;
        var r &#x3D; d.r + node.r;
        if (l &lt; r * r) {
          var c1, c2, lambda1, lambda2, u1, u2;
          var delta &#x3D; Math.sqrt(l);
          if (d.r &lt; node.r) {
            c1 &#x3D; node; c2 &#x3D; d;
          } else {
            c1 &#x3D; d; c2 &#x3D; node;
          }
          var r1 &#x3D; c1.r;
          var r2 &#x3D; c2.r;
          var alpha &#x3D; (r1 + r2 + delta) / 4;
          if (l &gt; 0) {
            u1 &#x3D; (c2.xp - c1.xp) / delta;
            u2 &#x3D; (c2.yp - c1.yp) / delta;
          } else {
            var theta &#x3D; 2 * Math.PI * Math.random();
            u1 &#x3D; Math.cos(theta);
            u2 &#x3D; Math.sin(theta);
          }

          if (r2 &gt;&#x3D; alpha) {
            lambda1 &#x3D; alpha / r1;
            lambda2 &#x3D; alpha / r2;
          } else {
            lambda1 &#x3D; (r1 - r2 + delta) / (2 * r1);
            if (lambda1 &gt; 1) { console.log(lambda1); }
            lambda2 &#x3D; 1;
          }
          c1.r *&#x3D; lambda1;
          c2.r *&#x3D; lambda2;
          c1.xp +&#x3D; (lambda1 - 1) * r1 * u1;
          c1.yp +&#x3D; (lambda1 - 1) * r1 * u2;
          c2.xp +&#x3D; (1 - lambda2) * r2 * u1;
          c2.yp +&#x3D; (1 - lambda2) * r2 * u2;
          c1.xMin &#x3D; c1.xp - c1.r;
          c1.xMax &#x3D; c1.xp + c1.r;
          c1.yMin &#x3D; c1.yp - c1.r;
          c1.yMax &#x3D; c1.yp + c1.r;
          c2.xMin &#x3D; c2.xp - c2.r;
          c2.xMax &#x3D; c2.xp + c2.r;
          c2.yMin &#x3D; c2.yp - c2.r;
          c2.yMax &#x3D; c2.yp + c2.r;
        }
      }
      return function(quad, x1, y1, x2, y2) {
        if (!quad.length) {
          do {
            if (quad.data !&#x3D; d &amp;&amp; d.xMax &gt; quad.data.xMin &amp;&amp; d.xMin &lt; quad.data.xMax &amp;&amp; d.yMax &gt; quad.data.yMin &amp;&amp; d.yMin &lt; quad.data.yMax) {
              fixCollision(quad.data);
            }
          } while (quad &#x3D; quad.next)
        }
        return x1 &gt; d.xMax + rMax || x2 + rMax &lt; d.xMin || y1 &gt; d.yMax + rMax || y2 + rMax &lt; d.yMin;
      };
    }
    tree.visit(collide(circle));
    rMax &#x3D; Math.max(rMax, circle.r);
    tree.add(circle);
  });
  if (opts.zoom !&#x3D;&#x3D; undefined) {
    circles.forEach(function(circle) {
      circle.cache &#x3D; circle.cache || {};
      circle.cache[opts.zoom] &#x3D; {
        x: circle.xp,
        y: circle.yp,
        r: circle.r
      };
    });
  }
  var ret &#x3D; d3.quadtree()
    .x(function(d) {return d.xp;})
    .y(function(d) {return d.yp;});
  var rMax2 &#x3D; 0;
  circles.forEach(function(circle) {
    ret.add(circle);
    rMax2 &#x3D; Math.max(rMax2, circle.r);
  })
  ret.rMax &#x3D; rMax2;
  return ret;
}
</textarea>
              <textarea class="hidden" name="css">/**
  * Create a position for the map
  * on the page */
#map {
  width: 100%;
  height: 100%;
}
</textarea>
              <textarea class="hidden" name="html">&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;main&quot;&gt;
  &lt;div id&#x3D;&quot;map&quot;&gt;
    &lt;div class&#x3D;&quot;legend geometry top center hide&quot;&gt;
      &lt;div class&#x3D;&quot;wrapper&quot;&gt;
        &lt;div class&#x3D;&quot;content&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</textarea>
              <input type="hidden" name="data">
            </form>
            <pre><code id="example-source" class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Leaflet poi example&lt;/title&gt;
    &lt;link rel="stylesheet" href="http://www.3daysofprogramming.com/playground/pg.css" type="text/css"&gt;
    &lt;!-- The line below is only needed for old environments like Internet Explorer and Android 4.x --&gt;
    &lt;script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL,Map,Set,Promise"&gt;&lt;/script&gt;
    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https://unpkg.com/leaflet@1.4.0/dist/leaflet.css&quot;&gt;
    &lt;script src&#x3D;&quot;https://unpkg.com/leaflet@1.4.0/dist/leaflet.js&quot;&gt;&lt;/script&gt;
    &lt;script src&#x3D;&quot;https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.7/pixi.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src&#x3D;&quot;https://cdn.jsdelivr.net/npm/leaflet-pixi-overlay@1.7.0/L.PixiOverlay.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src&#x3D;&quot;https://d3js.org/d3.v5.min.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      /**
        * Create a position for the map
        * on the page */
      #map {
        width: 100%;
        height: 100%;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;main&quot;&gt;
      &lt;div id&#x3D;&quot;map&quot;&gt;
        &lt;div class&#x3D;&quot;legend geometry top center hide&quot;&gt;
          &lt;div class&#x3D;&quot;wrapper&quot;&gt;
            &lt;div class&#x3D;&quot;content&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
      var map &#x3D; L.map(&#x27;map&#x27;).setView([37.49229399862877, -96.94335937500001], 4);
      var tileLayer &#x3D; L.tileLayer(&#x27;//stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png&#x27;, {
        subdomains: &#x27;abcd&#x27;,
        attribution: &#x27;Map tiles by &lt;a href&#x3D;&quot;http://stamen.com&quot;&gt;Stamen Design&lt;/a&gt;, under &lt;a href&#x3D;&quot;http://creativecommons.org/licenses/by/3.0&quot;&gt;CC BY 3.0&lt;/a&gt;. Data by &lt;a href&#x3D;&quot;http://openstreetmap.org&quot;&gt;OpenStreetMap&lt;/a&gt;, under &lt;a href&#x3D;&quot;http://www.openstreetmap.org/copyright&quot;&gt;ODbL&lt;/a&gt;.&#x27;,
        minZoom: 4,
        maxZoom: 18
      });
      map.attributionControl.setPosition(&#x27;bottomleft&#x27;);
      map.zoomControl.setPosition(&#x27;bottomright&#x27;);

      map.addLayer(tileLayer);

      tileLayer.on(&#x27;load&#x27;, function () {
        Array.from(document.getElementsByClassName(&#x27;leaflet-tile&#x27;)).forEach(function (tile) {
          tile.style.height &#x3D; (tile.clientHeight + 1) + &#x27;px&#x27;;
          tile.style.width &#x3D; (tile.clientWidth + 1) + &#x27;px&#x27;;
        });
      });

      var getJSON &#x3D; function(url, successHandler, errorHandler) {
        var xhr &#x3D; typeof XMLHttpRequest !&#x3D; &#x27;undefined&#x27;
          ? new XMLHttpRequest()
          : new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);
        xhr.open(&#x27;get&#x27;, url, true);
        xhr.onreadystatechange &#x3D; function() {
          var status;
          var data;
          if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) {
            status &#x3D; xhr.status;
            if (status &#x3D;&#x3D;&#x3D; 200) {
              data &#x3D; JSON.parse(xhr.responseText);
              successHandler &amp;&amp; successHandler(data);
            } else {
              errorHandler &amp;&amp; errorHandler(status);
            }
          }
        };
        xhr.send();
      };

      var loader &#x3D; new PIXI.loaders.Loader();
      loader
        .add(&#x27;plane&#x27;, &#x27;data/img/leaflet/plane.png&#x27;)
        .add(&#x27;focusPlane&#x27;, &#x27;data/img/leaflet/focus-plane.png&#x27;)
        .add(&#x27;circle&#x27;, &#x27;data/img/leaflet/circle.png&#x27;)
        .add(&#x27;focusCircle&#x27;, &#x27;data/img/leaflet/focus-circle.png&#x27;)
        .add(&#x27;bicycle&#x27;, &#x27;data/img/leaflet/bicycle.png&#x27;)
        .add(&#x27;focusBicycle&#x27;, &#x27;data/img/leaflet/focus-bicycle.png&#x27;);
      document.addEventListener(&quot;DOMContentLoaded&quot;, function () {
        loader.load(load);
      });

      function load(loader, resources) {
        var textures &#x3D; [resources.plane.texture, resources.circle.texture, resources.bicycle.texture];
        var focusTextures &#x3D; [resources.focusPlane.texture, resources.focusCircle.texture, resources.focusBicycle.texture];
        getJSON(&#x27;data/json/cities.json&#x27;, function(markers) {

          var legend &#x3D; document.querySelector(&#x27;div.legend.geometry&#x27;);
          var legendContent &#x3D; legend.querySelector(&#x27;.content&#x27;);
          var pixiLayer &#x3D; (function () {
            var firstDraw &#x3D; true;
            var prevZoom;
            var markerSprites &#x3D; [];
            var colorScale &#x3D; d3.scaleLinear()
              .domain([0, 50, 100])
              .range([&quot;#c6233c&quot;, &quot;#ffd300&quot;, &quot;#008000&quot;]);
            var frame &#x3D; null;
            var focus &#x3D; null;
            var pixiContainer &#x3D; new PIXI.Container();
            var doubleBuffering &#x3D; /iPad|iPhone|iPod/.test(navigator.userAgent) &amp;&amp; !window.MSStream;
            return L.pixiOverlay(function(utils) {
              var zoom &#x3D; utils.getMap().getZoom();
              if (frame) {
                cancelAnimationFrame(frame);
                frame &#x3D; null;
              }
              var container &#x3D; utils.getContainer();
              var renderer &#x3D; utils.getRenderer();
              var project &#x3D; utils.latLngToLayerPoint;
              var scale &#x3D; utils.getScale();
              var invScale &#x3D; 1 / scale;
              if (firstDraw) {
                prevZoom &#x3D; zoom;
                markers.forEach(function (marker) {
                  var coords &#x3D; project([marker.latitude, marker.longitude]);
                  var index &#x3D; Math.floor(Math.random() * textures.length);
                  var markerSprite &#x3D; new PIXI.Sprite(textures[index]);
                  markerSprite.textureIndex &#x3D; index;
                  markerSprite.x0 &#x3D; coords.x;
                  markerSprite.y0 &#x3D; coords.y;
                  markerSprite.anchor.set(0.5, 0.5);
                  var tint &#x3D; d3.color(colorScale(marker.avancement || Math.random() * 100)).rgb();
                  markerSprite.tint &#x3D; 256 * (tint.r * 256 + tint.g) + tint.b;
                  container.addChild(markerSprite);
                  markerSprites.push(markerSprite);
                  markerSprite.legend &#x3D; marker.city || marker.label;
                });
                var quadTrees &#x3D; {};
                for (var z &#x3D; map.getMinZoom(); z &lt;&#x3D; map.getMaxZoom(); z++) {
                  var rInit &#x3D; ((z &lt;&#x3D; 7) ? 16 : 24) / utils.getScale(z);
                  quadTrees[z] &#x3D; solveCollision(markerSprites, {r0: rInit, zoom: z});
                }
                map.on(&#x27;click&#x27;, function (e) {
                  var redraw &#x3D; false;
                  if (focus) {
                    focus.texture &#x3D; textures[focus.textureIndex];
                    focus &#x3D; null;
                    L.DomUtil.addClass(legend, &#x27;hide&#x27;);
                    legendContent.innerHTML &#x3D; &#x27;&#x27;;
                    redraw &#x3D; true;
                  }
                  var marker &#x3D; findMarker(e.latlng, project, quadTrees, utils);
                  if (marker) {
                    marker.texture &#x3D; focusTextures[marker.textureIndex];
                    focus &#x3D; marker;
                    legendContent.innerHTML &#x3D; marker.legend;
                    L.DomUtil.removeClass(legend, &#x27;hide&#x27;);
                    redraw &#x3D; true;
                  }
                  if (redraw) { utils.getRenderer().render(container); }
                });
                var self &#x3D; this;
                map.on(&#x27;mousemove&#x27;, L.Util.throttle(function (e) {
                  var marker &#x3D; findMarker(e.latlng, project, quadTrees, utils);
                  if (marker) {
                    L.DomUtil.addClass(self._container, &#x27;leaflet-interactive&#x27;);
                  } else {
                    L.DomUtil.removeClass(self._container, &#x27;leaflet-interactive&#x27;);
                  }
                }, 32));
              }
              if (firstDraw || prevZoom !&#x3D;&#x3D; zoom) {
                markerSprites.forEach(function (markerSprite) {
                  var position &#x3D; markerSprite.cache[zoom];
                  if (firstDraw) {
                    markerSprite.x &#x3D; position.x;
                    markerSprite.y &#x3D; position.y;
                    markerSprite.scale.set((position.r * scale &lt; 16) ? position.r / 16 : invScale);
                  } else {
                    markerSprite.currentX &#x3D; markerSprite.x;
                    markerSprite.currentY &#x3D; markerSprite.y;
                    markerSprite.targetX &#x3D; position.x;
                    markerSprite.targetY &#x3D; position.y;
                    markerSprite.currentScale &#x3D; markerSprite.scale.x;
                    markerSprite.targetScale &#x3D; (position.r * scale &lt; 16) ? position.r / 16 : invScale;
                  }
                });
              }
              function findMarker(ll, project, quadTrees, utils) {
                var layerPoint &#x3D; project(ll);
                var quadTree &#x3D; quadTrees[utils.getMap().getZoom()];
                var marker;
                var rMax &#x3D; quadTree.rMax;
                var found &#x3D; false;
                quadTree.visit(function (quad, x1, y1, x2, y2) {
                  if (!quad.length) {
                    var dx &#x3D; quad.data.x - layerPoint.x;
                    var dy &#x3D; quad.data.y - layerPoint.y;
                    var r &#x3D; quad.data.scale.x * 16;
                    if (dx * dx + dy * dy &lt;&#x3D; r * r) {
                      marker &#x3D; quad.data;
                      found &#x3D; true;
                    }
                  }
                  return found || x1 &gt; layerPoint.x + rMax || x2 + rMax &lt; layerPoint.x || y1 &gt; layerPoint.y + rMax || y2 + rMax &lt; layerPoint.y;
                });
                return marker;
              }

              var start &#x3D; null;
              var delta &#x3D; 250;
              function animate(timestamp) {
                var progress;
                if (start &#x3D;&#x3D;&#x3D; null) { start &#x3D; timestamp; }
                progress &#x3D; timestamp - start;
                var lambda &#x3D; progress / delta;
                if (lambda &gt; 1) { lambda &#x3D; 1; }
                lambda &#x3D; lambda * (0.4 + lambda * (2.2 + lambda * -1.6));
                markerSprites.forEach(function(markerSprite) {
                  markerSprite.x &#x3D; markerSprite.currentX + lambda * (markerSprite.targetX - markerSprite.currentX);
                  markerSprite.y &#x3D; markerSprite.currentY + lambda * (markerSprite.targetY - markerSprite.currentY);
                  markerSprite.scale.set(markerSprite.currentScale + lambda * (markerSprite.targetScale - markerSprite.currentScale));
                });
                renderer.render(container);
                if (progress &lt; delta) {
                  frame &#x3D; requestAnimationFrame(animate);
                }
              }
              if (!firstDraw &amp;&amp; prevZoom !&#x3D;&#x3D; zoom) {
                frame &#x3D; requestAnimationFrame(animate);
              }
              firstDraw &#x3D; false;
              prevZoom &#x3D; zoom;
              renderer.render(container);
            }, pixiContainer, {
              doubleBuffering: doubleBuffering,
              destroyInteractionManager: true
            });
          })();
          pixiLayer.addTo(map);
        });
      }

      function solveCollision(circles, opts) {
        opts &#x3D; opts || {};
        var tree &#x3D; d3.quadtree()
          .x(function(d) {return d.xp;})
          .y(function(d) {return d.yp;});
        if (opts.extent !&#x3D;&#x3D; undefined) { tree.extent(opts.extent); }
        var rMax &#x3D; 0;
        circles.forEach(function(circle) {
          circle.xp &#x3D; circle.x0;
          circle.yp &#x3D; circle.y0;
          if (opts.r0 !&#x3D;&#x3D; undefined) { circle.r0 &#x3D; opts.r0; }
          circle.r &#x3D; circle.r0;
          circle.xMin &#x3D; circle.x0 - circle.r0;
          circle.xMax &#x3D; circle.x0 + circle.r0;
          circle.yMin &#x3D; circle.y0 - circle.r0;
          circle.yMax &#x3D; circle.y0 + circle.r0;

          function collide(d) {
            function fixCollision(node) {
              var x &#x3D; d.xp - node.xp;
              var y &#x3D; d.yp - node.yp;
              var l &#x3D; x * x + y * y;
              var r &#x3D; d.r + node.r;
              if (l &lt; r * r) {
                var c1, c2, lambda1, lambda2, u1, u2;
                var delta &#x3D; Math.sqrt(l);
                if (d.r &lt; node.r) {
                  c1 &#x3D; node; c2 &#x3D; d;
                } else {
                  c1 &#x3D; d; c2 &#x3D; node;
                }
                var r1 &#x3D; c1.r;
                var r2 &#x3D; c2.r;
                var alpha &#x3D; (r1 + r2 + delta) / 4;
                if (l &gt; 0) {
                  u1 &#x3D; (c2.xp - c1.xp) / delta;
                  u2 &#x3D; (c2.yp - c1.yp) / delta;
                } else {
                  var theta &#x3D; 2 * Math.PI * Math.random();
                  u1 &#x3D; Math.cos(theta);
                  u2 &#x3D; Math.sin(theta);
                }

                if (r2 &gt;&#x3D; alpha) {
                  lambda1 &#x3D; alpha / r1;
                  lambda2 &#x3D; alpha / r2;
                } else {
                  lambda1 &#x3D; (r1 - r2 + delta) / (2 * r1);
                  if (lambda1 &gt; 1) { console.log(lambda1); }
                  lambda2 &#x3D; 1;
                }
                c1.r *&#x3D; lambda1;
                c2.r *&#x3D; lambda2;
                c1.xp +&#x3D; (lambda1 - 1) * r1 * u1;
                c1.yp +&#x3D; (lambda1 - 1) * r1 * u2;
                c2.xp +&#x3D; (1 - lambda2) * r2 * u1;
                c2.yp +&#x3D; (1 - lambda2) * r2 * u2;
                c1.xMin &#x3D; c1.xp - c1.r;
                c1.xMax &#x3D; c1.xp + c1.r;
                c1.yMin &#x3D; c1.yp - c1.r;
                c1.yMax &#x3D; c1.yp + c1.r;
                c2.xMin &#x3D; c2.xp - c2.r;
                c2.xMax &#x3D; c2.xp + c2.r;
                c2.yMin &#x3D; c2.yp - c2.r;
                c2.yMax &#x3D; c2.yp + c2.r;
              }
            }
            return function(quad, x1, y1, x2, y2) {
              if (!quad.length) {
                do {
                  if (quad.data !&#x3D; d &amp;&amp; d.xMax &gt; quad.data.xMin &amp;&amp; d.xMin &lt; quad.data.xMax &amp;&amp; d.yMax &gt; quad.data.yMin &amp;&amp; d.yMin &lt; quad.data.yMax) {
                    fixCollision(quad.data);
                  }
                } while (quad &#x3D; quad.next)
              }
              return x1 &gt; d.xMax + rMax || x2 + rMax &lt; d.xMin || y1 &gt; d.yMax + rMax || y2 + rMax &lt; d.yMin;
            };
          }
          tree.visit(collide(circle));
          rMax &#x3D; Math.max(rMax, circle.r);
          tree.add(circle);
        });
        if (opts.zoom !&#x3D;&#x3D; undefined) {
          circles.forEach(function(circle) {
            circle.cache &#x3D; circle.cache || {};
            circle.cache[opts.zoom] &#x3D; {
              x: circle.xp,
              y: circle.yp,
              r: circle.r
            };
          });
        }
        var ret &#x3D; d3.quadtree()
          .x(function(d) {return d.xp;})
          .y(function(d) {return d.yp;});
        var rMax2 &#x3D; 0;
        circles.forEach(function(circle) {
          ret.add(circle);
          rMax2 &#x3D; Math.max(rMax2, circle.r);
        })
        ret.rMax &#x3D; rMax2;
        return ret;
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>

  <script src="./resources/common.js"></script>
  <script src="./resources/prism/prism.min.js"></script>
  <script src="common.js"></script><script src="leaflet-poi.js"></script>
  </body>
</html>
