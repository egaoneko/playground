{"version":3,"sources":["webpack:///./webgl-optimize-7.js"],"names":["let","gl","canvas","container","glProgram","fragmentShader","vertexShader","vertexPositionAttribute","vertexNormalAttribute","vertexTexCoordAttribute","trianglesInterleavedBuffers","vertexIndexBuffers","spherePositions","currentTime","texture","textureImage","textureFilename","textureAtlasAreas","pMatrix","mat4","create","mvMatrix","normalMatrix","mat3","unit_sphere","num_per_batch","batches","paused","SpherePosition","this","x_offset_orig","Math","random","y_offset_orig","z_offset_orig","x_offset","y_offset","z_offset","x_angle","y_angle","z_angle","angle","radius","i","push","makeShader","source","type","const","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","window","addEventListener","document","querySelector","width","clientWidth","height","clientHeight","getContext","e","console","error","vsSource","fsSource","VERTEX_SHADER","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","initShaders","vertices","uvs","latNumber","theta","PI","sinTheta","sin","cosTheta","cos","longNumber","phi","sinPhi","cosPhi","x","y","z","u","v","calculateUnitSpherePoints","interleavedData","indexData","j","mesh_number","active_num","tex_start_x","tex_start_y","tex_scale_x","tex_scale_y","first","second","vertex","uv","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","itemSize","numItems","length","ELEMENT_ARRAY_BUFFER","Uint16Array","STREAM_DRAW","setupSphereData","pMatrixUniform","getUniformLocation","mvMatrixUniform","normalMatrixUniform","samplerUniform","cosTimeUniform","sinTimeUniform","Image","onload","activeTexture","TEXTURE0","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","generateMipmap","isTexture","src","viewport","perspective","uniformMatrix4fv","getAttribLocation","enableVertexAttribArray","identity","translate","invertedMatrix","fromMat4","invert","transpose","uniformMatrix3fv","animLoop","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","DEPTH_TEST","uniform1f","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawElements","TRIANGLES","UNSIGNED_SHORT","drawScene","requestAnimationFrame","evt","keyCode"],"mappings":"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","file":"webgl-optimize-7.js","sourcesContent":["let gl = null;\nlet canvas = null;\nlet container = null;\nlet glProgram = null;\nlet fragmentShader = null;\nlet vertexShader = null;\n\nlet vertexPositionAttribute = null;\nlet vertexNormalAttribute = null;\nlet vertexTexCoordAttribute = null;\nconst trianglesInterleavedBuffers = [];\nconst vertexIndexBuffers = [];\n\nconst spherePositions = [];\nlet currentTime = 0.0;\n\nlet texture = null;\nlet textureImage = null;\nlet textureFilename = \"texture_atlas.jpg\";\n//x_offset, y_offset, x_scale, y_scale\nconst textureAtlasAreas = [\n  [0.0, 0.0, 0.5, 0.5], //moon\n  [0.5, 0.0, 0.5, 0.5], //sun\n  [0.0, 0.5, 0.25, 0.25], //saturn\n  [0.0, 0.75, 0.25, 0.25], //jupiter\n  [0.5, 0.5, 0.25, 0.25], //earth\n  [0.5, 0.75, 0.25, 0.25] //mars\n];\nconst texture_directory = 'data/img/';\n\ntextureFilename = texture_directory + textureFilename;\n\nlet pMatrix = mat4.create();\nlet mvMatrix = mat4.create();\nlet normalMatrix = mat3.create();\n\nlet unit_sphere = null;\n\nconst num_spheres = 20000;\nconst num_per_batch = 250;\nconst batches = num_spheres / num_per_batch;\n\nlet paused = false;\n\nclass SpherePosition {\n  constructor() {\n    this.x_offset_orig = 10.0 - Math.random() * 20.0;\n    this.y_offset_orig = 10.0 - Math.random() * 20.0;\n    this.z_offset_orig = -25.0 + Math.random() * 12.0;\n\n    this.x_offset = this.x_offset_orig;\n    this.y_offset = this.y_offset_orig;\n    this.z_offset = this.z_offset_orig;\n\n    this.x_angle = Math.random() * 360;\n    this.y_angle = Math.random() * 360;\n    this.z_angle = Math.random() * 360;\n    this.angle = 0.005;\n    this.radius = 0.1 + Math.random() * .2;\n  }\n}\n\nfor (let i = 0; i < num_spheres; ++i) {\n  spherePositions.push(new SpherePosition());\n}\n\nwindow.addEventListener('load', initWebGL);\ndocument.addEventListener('keyup', (evt) => {\n  switch (evt.keyCode) {\n    case 80: // 'p'\n      paused = !paused;\n      break;\n  }\n});\n\nfunction initWebGL() {\n  canvas = document.querySelector('#canvas');\n  container = document.querySelector('#container');\n  canvas.width = container.clientWidth;\n  canvas.height = container.clientHeight;\n\n  try {\n    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  } catch (e) {\n    console.error(e);\n  }\n\n  if (gl) {\n    initShaders();\n\n    setupSphereData();\n\n    getMatrixUniforms();\n    loadTexture();\n\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);\n    gl.uniformMatrix4fv(glProgram.pMatrixUniform, false, pMatrix);\n    vertexPositionAttribute = gl.getAttribLocation(glProgram, 'aVertexPosition');\n    vertexNormalAttribute = gl.getAttribLocation(glProgram, 'aVertexNormal');\n    vertexTexCoordAttribute = gl.getAttribLocation(glProgram, 'aVertexTexCoord');\n    gl.enableVertexAttribArray(vertexPositionAttribute);\n    gl.enableVertexAttribArray(vertexNormalAttribute);\n    gl.enableVertexAttribArray(vertexTexCoordAttribute);\n\n    mat4.identity(mvMatrix);\n    mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);\n    mat4.identity(normalMatrix);\n\n    const invertedMatrix = mat3.create();\n    mat3.fromMat4(invertedMatrix, mvMatrix);\n    mat3.invert(normalMatrix, invertedMatrix);\n    mat3.transpose(normalMatrix, normalMatrix);\n\n    setMatrixUniforms();\n\n    (function animLoop() {\n\n      if (!paused) {\n        setupWebGL();\n        drawScene();\n      }\n\n      requestAnimationFrame(animLoop);\n    })();\n  }\n}\n\nfunction setupWebGL() {\n  // set the clear color to a shade of green\n  gl.clearColor(0.1, 0.5, 0.1, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.enable(gl.DEPTH_TEST);\n}\n\nfunction initShaders() {\n  // get shader source\n  const vsSource = vertexShaderSource();\n  const fsSource = fragmentShaderSource();\n\n  // compile shaders\n  vertexShader = makeShader(vsSource, gl.VERTEX_SHADER);\n  fragmentShader = makeShader(fsSource, gl.FRAGMENT_SHADER);\n\n  // create program\n  glProgram = gl.createProgram();\n\n  // attach and link shaders to the program\n  gl.attachShader(glProgram, vertexShader);\n  gl.attachShader(glProgram, fragmentShader);\n  gl.linkProgram(glProgram);\n\n  if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n    alert('Unable to initialize the shader program.');\n  }\n\n  // use program\n  gl.useProgram(glProgram);\n}\n\nfunction makeShader(source, type) {\n  // compile the shader\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);\n  }\n\n  return shader;\n}\n\nfunction vertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexNormal;\n    attribute vec2 aVertexTexCoord;\n    \n    uniform mat3 uNormalMatrix;\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n    uniform float uCosTime;\n    uniform float uSinTime;\n    \n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    void main(void) {\n      vec3 modifiedPosition = vec3(uCosTime + aVertexPosition.x, uSinTime+aVertexPosition.y, aVertexPosition.z + 4.0*uSinTime );\n      gl_Position = uPMatrix * uMVMatrix * vec4(modifiedPosition, 1.0);\n      vTextureCoord = aVertexTexCoord;\n      \n      vec3 pointLightPosition = vec3(1.0,2.0,-1.0);\n      vec3 pointLightDirection = normalize(vec3(pointLightPosition.xyz - modifiedPosition));\n      \n      vec3 L = vec3(uPMatrix * uMVMatrix * vec4(pointLightDirection, 1.0));\n      vec3 N = uNormalMatrix * aVertexNormal;\n      float lambert = max(dot(normalize(N), normalize(L)), 0.0);\n      vLight = 0.1 + lambert;\n    }\n  `;\n}\n\nfunction fragmentShaderSource() {\n  return `\n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    uniform sampler2D uSampler;\n    \n    void main(void) {\n      highp vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.st));\n      gl_FragColor = vec4(textureColor.xyz * vLight, textureColor.a);\n    }\n  `;\n}\n\nfunction drawScene() {\n  gl.uniform1f(glProgram.cosTimeUniform, Math.cos(currentTime));\n  gl.uniform1f(glProgram.sinTimeUniform, Math.sin(currentTime));\n  for (let i = 0; i < batches; ++i) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      3 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      6 * Float32Array.BYTES_PER_ELEMENT);\n    gl.drawElements(gl.TRIANGLES, vertexIndexBuffers[i].numItems, gl.UNSIGNED_SHORT, 0);\n  }\n  currentTime += 0.01;\n}\n\nfunction calculateUnitSpherePoints() {\n  // 2*(1+longitudeBands) * latitudeBands trig operations - costly!\n  const latitudeBands = 10;\n  const longitudeBands = 10;\n  unit_sphere = {\n    \"vertices\": [],\n    \"uvs\": []\n  };\n\n  for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n    const theta = latNumber * Math.PI / latitudeBands;\n    const sinTheta = Math.sin(theta);\n    const cosTheta = Math.cos(theta);\n\n    for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n      const phi = longNumber * 2 * Math.PI / longitudeBands;\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n\n      const x = cosPhi * sinTheta;\n      const y = cosTheta;\n      const z = sinPhi * sinTheta;\n      const u = 1 - (longNumber / longitudeBands);\n      const v = latNumber / latitudeBands;\n\n      //position\n      unit_sphere.vertices.push({\"x\": x, \"y\": y, \"z\": z});\n      //texture coordinates\n      unit_sphere.uvs.push({\"u\": u, \"v\": v});\n    }\n  }\n}\n\n//modified from http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere\nfunction setupSphereData() {\n  const latitudeBands = 10;\n  const longitudeBands = 10;\n  calculateUnitSpherePoints();\n\n  for (let i = 0; i < batches; ++i) {\n    const interleavedData = [];\n    const indexData = [];\n\n    for (let j = 0; j < num_per_batch; ++j) {\n      const mesh_number = i * num_per_batch + j;\n      const active_num = mesh_number % 6;\n      const tex_start_x = textureAtlasAreas[active_num][0];\n      const tex_start_y = textureAtlasAreas[active_num][1];\n      const tex_scale_x = textureAtlasAreas[active_num][2];\n      const tex_scale_y = textureAtlasAreas[active_num][3];\n\n      const radius = spherePositions[mesh_number].radius;\n\n      for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n        for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n          const first = j * latitudeBands * (longitudeBands + 1) + (latNumber * (longitudeBands + 1)) + longNumber;\n          const second = first + longitudeBands + 1;\n          const vertex = unit_sphere.vertices[latNumber * (longitudeBands + 1) + longNumber];\n          const uv = unit_sphere.uvs[latNumber * (longitudeBands + 1) + longNumber];\n          //position\n          interleavedData.push(radius * vertex.x + spherePositions[mesh_number].x_offset_orig);\n          interleavedData.push(radius * vertex.y + spherePositions[mesh_number].y_offset_orig);\n          interleavedData.push(radius * vertex.z + spherePositions[mesh_number].z_offset_orig);\n          //normal\n          interleavedData.push(vertex.x);\n          interleavedData.push(vertex.y);\n          interleavedData.push(vertex.z);\n\n          //texture coordinates\n          interleavedData.push(uv.u * tex_scale_x + tex_start_x);\n          interleavedData.push(uv.v * tex_scale_y + tex_start_y);\n\n          //indices\n          if ((latNumber < latitudeBands) && (longNumber < longitudeBands)) {\n            indexData.push(first);\n            indexData.push(second);\n            indexData.push(first + 1);\n\n            indexData.push(second);\n            indexData.push(second + 1);\n            indexData.push(first + 1);\n          }\n        }\n      }\n    }\n    trianglesInterleavedBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(interleavedData), gl.STATIC_DRAW);\n    trianglesInterleavedBuffers[i].itemSize = 8;\n    trianglesInterleavedBuffers[i].numItems = interleavedData.length / 8;\n\n    vertexIndexBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffers[i]);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);\n    vertexIndexBuffers[i].itemSize = 3;\n    vertexIndexBuffers[i].numItems = indexData.length;\n  }\n}\n\nfunction getMatrixUniforms() {\n  glProgram.pMatrixUniform = gl.getUniformLocation(glProgram, \"uPMatrix\");\n  glProgram.mvMatrixUniform = gl.getUniformLocation(glProgram, \"uMVMatrix\");\n  glProgram.normalMatrixUniform = gl.getUniformLocation(glProgram, \"uNormalMatrix\");\n  glProgram.samplerUniform = gl.getUniformLocation(glProgram, \"uSampler\");\n  glProgram.cosTimeUniform = gl.getUniformLocation(glProgram, \"uCosTime\");\n  glProgram.sinTimeUniform = gl.getUniformLocation(glProgram, \"uSinTime\");\n}\n\nfunction setMatrixUniforms() {\n  gl.uniformMatrix4fv(glProgram.mvMatrixUniform, false, mvMatrix);\n  gl.uniformMatrix3fv(glProgram.normalMatrixUniform, false, normalMatrix);\n}\n\nfunction loadTexture() {\n  textureImage = new Image();\n  textureImage.onload = function () {\n    setupTexture();\n  };\n  textureImage.src = textureFilename;\n}\n\nfunction setupTexture() {\n  gl.activeTexture(gl.TEXTURE0);\n  texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.generateMipmap(gl.TEXTURE_2D);\n  if (!gl.isTexture(texture)) {\n    console.error(\"Error: Texture is invalid\");\n  }\n}\n"],"sourceRoot":""}