{"version":3,"sources":["webpack:///./create-image-bitmap.js","webpack:///./utils/box.js"],"names":["__webpack_require__","r","__webpack_exports__","imageBox","_utils_box__WEBPACK_IMPORTED_MODULE_0__","sprites","sprite01","x","y","w","h","sprite02","sprite03","sprite04","sprite05","sprite06","imageCanvas","document","getElementById","spriteSheet","Promise","resolve","reject","const","loadedSprites","loadedSpriteSheet","Image","src","onload","Object","keys","forEach","name","push","spriteName","canvas","createElement","ctx","getContext","sprite","width","height","drawImage","getSprite","onerror","e","getSpritesFromCanvas","then","images","ratio","window","devicePixelRatio","imageBitmapBox","createImageBitmapCanvas","bitmaps","createImageBitmap","all","loadedBitmap","getSpritesFromImageBitmap","addEventListener","container","clientWidth","clientHeight","resize","Box","option","assign","this","init","animate","prototype","camera","THREE","PerspectiveCamera","position","z","lookAt","Vector3","scene","Scene","ambiLight","AmbientLight","add","light","DirectionalLight","set","cube","createMesh","BoxGeometry","console","log","geometry","faceVertexUvs","renderer","WebGLRenderer","alpha","setClearColor","Color","setPixelRatio","shadowMapEnabled","geom","mat","length","MeshFaceMaterial","map","image","createMaterial","Mesh","let","texture","TextureLoader","load","CanvasTexture","MeshPhongMaterial","requestAnimationFrame","bind","render","time","Date","now","rotation","aspect","updateProjectionMatrix","setSize"],"mappings":"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","file":"create-image-bitmap.js","sourcesContent":["import Box from './utils/box';\n\nconst sprites = {\n  'sprite01': {\n    x: 557 * 0,\n    y: 0,\n    w: 557,\n    h: 557\n  },\n  'sprite02': {\n    x: 557 * 1,\n    y: 0,\n    w: 557,\n    h: 557\n  },\n  'sprite03': {\n    x: 557 * 2,\n    y: 0,\n    w: 557,\n    h: 557\n  },\n  'sprite04': {\n    x: 557 * 3,\n    y: 0,\n    w: 557,\n    h: 557\n  },\n  'sprite05': {\n    x: 557 * 4,\n    y: 0,\n    w: 557,\n    h: 557\n  },\n  'sprite06': {\n    x: 557 * 5,\n    y: 0,\n    w: 557,\n    h: 557\n  },\n};\n\nconst imageCanvas = document.getElementById('canvas-image');\nlet imageBox;\n\ngetSpritesFromCanvas('data/img/dice.png', sprites)\n  .then(images => {\n    imageBox = new Box(imageCanvas, {\n      images,\n      ratio: window.devicePixelRatio\n    });\n  });\n\nfunction getSpritesFromCanvas(spriteSheet, sprites) {\n  return new Promise((resolve, reject) => {\n    const loadedSprites = [];\n    const loadedSpriteSheet = new Image();\n\n    loadedSpriteSheet.src = spriteSheet;\n    loadedSpriteSheet.onload = () => {\n      Object\n        .keys(sprites)\n        .forEach(name => {\n          loadedSprites.push(getSprite(loadedSpriteSheet, sprites, name));\n        });\n      resolve(loadedSprites);\n    };\n    loadedSpriteSheet.onerror = e => {\n      reject(e);\n    }\n  });\n}\n\nfunction getSprite(spriteSheet, sprites, spriteName) {\n  const canvas = document.createElement('CANVAS');\n  const ctx = canvas.getContext('2d');\n  const sprite = sprites[spriteName];\n\n  canvas.width = sprite.w;\n  canvas.height = sprite.h;\n  ctx.drawImage(spriteSheet,\n    sprite.x, sprite.y, sprite.w, sprite.h,\n    0, 0, sprite.w, sprite.h\n  );\n\n  return canvas;\n}\n\nconst createImageBitmapCanvas = document.getElementById('canvas-image-bitmap');\nlet imageBitmapBox;\n\ngetSpritesFromImageBitmap('data/img/dice.png', sprites)\n  .then(images => {\n    imageBitmapBox = new Box(createImageBitmapCanvas, {\n      images,\n      ratio: window.devicePixelRatio,\n    });\n  });\n\nfunction getSpritesFromImageBitmap(spriteSheet, sprites) {\n  return new Promise((resolve, reject) => {\n    const bitmaps = [];\n    const loadedSpriteSheet = new Image();\n\n    loadedSpriteSheet.src = spriteSheet;\n    loadedSpriteSheet.onload = () => {\n      Object\n        .keys(sprites)\n        .forEach(name => {\n          const sprite = sprites[name];\n          bitmaps.push(\n            createImageBitmap(loadedSpriteSheet, sprite.x, sprite.y, sprite.w, sprite.h)\n          );\n        });\n      Promise\n        .all(bitmaps)\n        .then(loadedBitmap => {\n          resolve(loadedBitmap);\n        });\n    };\n    loadedSpriteSheet.onerror = e => {\n      reject(e);\n    }\n  });\n}\n\nwindow.addEventListener('resize', onWindowResize, false);\n\nfunction onWindowResize() {\n  const container = document.getElementById('container');\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n\n  imageBox.resize(width, height);\n  imageBitmapBox.resize(width, height);\n}\n","export default class Box {\n  constructor(container, option) {\n    if (!container) {\n      return;\n    }\n\n    option = Object.assign({\n      width: 300,\n      height: 300,\n      ratio: 1,\n      images: []\n    }, option);\n\n    this.container = container;\n    this.width = option.width;\n    this.height = option.height;\n    this.ratio = option.ratio;\n    this.images = option.images;\n\n    this.init();\n    this.animate();\n  }\n\n  init() {\n    // Resize to the screen\n    if (this.container.width !== this.width || this.container.width !== this.height) {\n      this.container.width = this.width;\n      this.container.height = this.height;\n    }\n\n    this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 0.1, 1000);\n    this.camera.position.x = 0;\n    this.camera.position.y = 12;\n    this.camera.position.z = 28;\n    this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n\n    this.scene = new THREE.Scene();\n\n    const ambiLight = new THREE.AmbientLight(0x141414);\n    this.scene.add(ambiLight);\n\n    const light = new THREE.DirectionalLight();\n    light.position.set(0, 30, 20);\n    this.scene.add(light);\n\n    this.cube = this.createMesh(new THREE.BoxGeometry(10, 10, 10), this.images);\n    this.scene.add(this.cube);\n    console.log(this.cube.geometry.faceVertexUvs);\n\n    this.renderer = new THREE.WebGLRenderer({\n      canvas: this.container,\n      alpha: true,\n    });\n    this.renderer.setClearColor(new THREE.Color(0xFFFFFFF, 0.0));\n    this.renderer.setPixelRatio(this.ratio);\n    this.renderer.shadowMapEnabled = true;\n  }\n\n  createMesh(geom, images) {\n    let mat;\n    if (images.length === 6) {\n      mat = new THREE.MeshFaceMaterial(images.map(image => this.createMaterial(image)));\n    } else {\n      mat = this.createMaterial(images[0]);\n    }\n    return new THREE.Mesh(geom, mat);\n  }\n\n  createMaterial(image) {\n    let texture;\n\n    if (typeof image === 'string') {\n      texture = new THREE.TextureLoader().load(image);\n    } else {\n      texture = new THREE.CanvasTexture(image);\n    }\n\n    const mat = new THREE.MeshPhongMaterial();\n    mat.map = texture;\n    return mat;\n  }\n\n  animate() {\n    requestAnimationFrame(this.animate.bind(this));\n    this.render();\n  }\n\n  render() {\n    const time = Date.now() * 0.001;\n    this.cube.rotation.x = time * 0.25;\n    this.cube.rotation.y = time * 0.5;\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  resize(width, height) {\n    this.width = width;\n    this.height = height;\n\n    if (this.container.width !== this.width || this.container.width !== this.height) {\n      this.container.width = this.width;\n      this.container.height = this.height;\n    }\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(this.width, this.height);\n  }\n}\n\n\n"],"sourceRoot":""}