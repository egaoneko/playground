{"version":3,"sources":["webpack:///./canvas-collision-detection-part2.js","webpack:///../src/pg/utils/math.js"],"names":["__webpack_require__","r","__webpack_exports__","_src_pg_utils_math__WEBPACK_IMPORTED_MODULE_0__","canvas","document","querySelector","ctx","getContext","mouse","x","y","colorSet","addEventListener","event","window","resize","Particle","dx","dy","radius","color","mass","this","interactiveSize","velocity","opacity","prototype","draw","beginPath","arc","Math","PI","globalAlpha","fillStyle","fill","strokeStyle","stroke","update","particles","forEach","particle","isCollided","Object","innerWidth","innerHeight","max","const","pow","let","cnt","width","height","length","some","p","i","push","loop","init","animate","clearRect","fillRect","requestAnimationFrame","randomInt","min","floor","random","rotate","angle","cos","sin","resolveCollision","otherParticle","xVelocityDiff","yVelocityDiff","atan2","m1","m2","u1","u2","v1","v2","vFinal1","vFinal2","d"],"mappings":"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","file":"canvas-collision-detection-part2.js","sourcesContent":["import {randomInt, resolveCollision} from '../src/pg/utils/math';\n\nconst canvas = document.querySelector('canvas');\nconst ctx = canvas.getContext('2d');\nconst mouse = {\n  x: 10,\n  y: 10\n};\nconst colorSet = [\n  '#8be9fd',\n  '#50fa7b',\n  '#ffb86c',\n  '#ff79c6',\n  '#bd93f9',\n  '#ff5555',\n  '#f1fa8c',\n];\n\ncanvas.addEventListener('mousemove', (event) => {\n  mouse.x = event.x;\n  mouse.y = event.y;\n});\n\nwindow.addEventListener('resize', () => {\n  resize();\n});\n\nclass Particle {\n  constructor(x, y, dx, dy, radius, color, mass) {\n    this.interactiveSize = 80;\n\n    this.x = x;\n    this.y = y;\n    this.velocity = {\n      x: dx,\n      y: dy\n    };\n    this.radius = radius;\n    this.color = color;\n    this.mass = mass;\n    this.opacity = 0;\n  }\n\n  draw() {\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);\n    ctx.globalAlpha = this.opacity;\n    ctx.fillStyle = this.color;\n    ctx.fill();\n    ctx.globalAlpha = 1;\n    ctx.strokeStyle = this.color;\n    ctx.stroke();\n  }\n\n  update(particles) {\n    this.draw();\n\n    // check collided\n    particles.forEach(particle => {\n      if (this === particle) {\n        return;\n      }\n\n      if (!this.isCollided(particle)) {\n        return;\n      }\n\n      resolveCollision(this, particle);\n    });\n\n    if (this.x + this.radius >= window.innerWidth || this.x - this.radius <= 0) {\n      this.velocity.x *= -1;\n    }\n\n    if (this.y + this.radius >= window.innerHeight || this.y - this.radius <= 0) {\n      this.velocity.y *= -1;\n    }\n\n    if (this.x - this.radius < 0) {\n      this.x = this.radius\n    }\n\n    if (this.y - this.radius < 0) {\n      this.y = this.radius\n    }\n\n    if (this.x + this.radius > window.innerWidth) {\n      this.x = window.innerWidth - this.radius;\n    }\n\n    if (this.y + this.radius > window.innerHeight) {\n      this.y = window.innerHeight - this.radius;\n    }\n\n    this.x += this.velocity.x;\n    this.y += this.velocity.y;\n\n    // mouse collide\n    if (\n      mouse.x - this.x < this.interactiveSize &&\n      mouse.x - this.x > -this.interactiveSize &&\n      mouse.y - this.y < this.interactiveSize &&\n      mouse.y - this.y > -this.interactiveSize &&\n      this.opacity < 0.5\n    ) {\n      this.opacity += 0.02\n    } else if (this.opacity > 0) {\n      this.opacity -= 0.02;\n      this.opacity = Math.max(0, this.opacity);\n    }\n  }\n\n  isCollided(particle) {\n    const x = this.x - particle.x;\n    const y = this.y - particle.y;\n    return (Math.pow(x, 2) + Math.pow(y, 2)) <= Math.pow((this.radius + particle.radius), 2);\n  }\n}\n\nlet particles = [];\nlet cnt = 0;\n\nfunction init() {\n\n  particles = [];\n\n  for (let i = 0; i < 100; i++) {\n    const radius = randomInt(8, 50);\n    const x = randomInt(radius, canvas.width - radius);\n    const dx = randomInt(-0.5, 0.5) * 5;\n    const y = randomInt(radius, canvas.height - radius);\n    const dy = randomInt(-0.5, 0.5) * 5;\n    const color = colorSet[randomInt(0, colorSet.length)];\n    const mass = 1;\n    const particle = new Particle(x, y, dx, dy, radius, color, mass);\n\n    if (particles.some(p => particle.isCollided(p))) {\n      cnt += 1;\n\n      if (cnt > 100) {\n        continue;\n      }\n\n      i -= 1;\n    } else {\n      cnt = 0;\n      particles.push(particle);\n    }\n  }\n}\n\nfunction resize() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n}\n\nfunction animate() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.fillStyle = '#282a36';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  particles.forEach(particle => particle.update(particles));\n  requestAnimationFrame(animate);\n}\n\nresize();\ninit();\nanimate();\n","/**\n * @module pg/utils/math\n */\n\n/**\n * Gets a random integer\n *\n * @param {number} min minimum number.\n * @param {number} max maximum number.\n * @return {number} The random integer number.\n * @api\n */\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Gets convex 2d numbers\n * @param {number} step step.\n * @return {array} The convex 2d numbers.\n * @api\n */\nexport function convex2d(step) {\n  const convex = [];\n\n  for (let i = 0; i < step; i++) {\n    const x = i / step;\n    convex.push([x, 1 - i / step]);\n  }\n  return convex;\n}\n\n/**\n * Rotates coordinate system for velocities\n *\n * Takes velocities and alters them as if the coordinate system they're on was rotated\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} velocity The velocity of an individual particle\n * @param {number} angle The angle of collision between two objects in radians\n * @return {Object} The altered x and y velocities after the coordinate system has been rotated\n */\nexport function rotate(velocity, angle) {\n  return {\n    x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),\n    y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)\n  };\n}\n\n/**\n * Swaps out two colliding particles' x and y velocities after running through\n * an elastic collision reaction equation\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} particle A particle object with x and y coordinates, plus velocity\n * @param {object} otherParticle A particle object with x and y coordinates, plus velocity\n * @return {boolean} success\n */\nexport function resolveCollision(particle, otherParticle) {\n  const xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;\n  const yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;\n\n  const xDist = otherParticle.x - particle.x;\n  const yDist = otherParticle.y - particle.y;\n\n  // Prevent accidental overlap of particles\n  if (xVelocityDiff * xDist + yVelocityDiff * yDist < 0) {\n    return false;\n  }\n\n  // Grab angle between the two colliding particles\n  const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);\n\n  // Store mass in var for better readability in collision equation\n  const m1 = particle.mass;\n  const m2 = otherParticle.mass;\n\n  // Velocity before equation\n  const u1 = rotate(particle.velocity, angle);\n  const u2 = rotate(otherParticle.velocity, angle);\n\n  // Velocity after 1d collision equation\n  const v1 = {x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y};\n  const v2 = {x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y};\n\n  // Final velocity after rotating axis back to original location\n  const vFinal1 = rotate(v1, -angle);\n  const vFinal2 = rotate(v2, -angle);\n\n  // Swap particle velocities for realistic bounce effect\n  particle.velocity.x = vFinal1.x;\n  particle.velocity.y = vFinal1.y;\n\n  otherParticle.velocity.x = vFinal2.x;\n  otherParticle.velocity.y = vFinal2.y;\n  return true;\n}\n"],"sourceRoot":""}