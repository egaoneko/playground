{"version":3,"sources":["webpack:///../src/pg/utils/math.js","webpack:///./utils/graphics/pixi/utils.js","webpack:///./utils/graphics/pixi/figure.js","webpack:///./utils/graphics/2d/convex-hull.js","webpack:///./utils/graphics/2d/projection.js","webpack:///./utils/graphics/2d/shape.js","webpack:///./utils/graphics/2d/vector.js","webpack:///./utils/graphics/2d/utils.js","webpack:///./utils/graphics/2d/mtv.js","webpack:///./utils/graphics/collision/sat.js","webpack:///./sat.js"],"names":["randomInt","min","max","Math","floor","random","rotate","velocity","angle","x","cos","y","sin","resolveCollision","particle","otherParticle","const","xVelocityDiff","yVelocityDiff","atan2","m1","mass","m2","u1","u2","v1","v2","vFinal1","vFinal2","__webpack_require__","d","__webpack_exports__","drawPoints","app","basis","points","style","graphics","PIXI","Graphics","forEach","point","Point","apply","lineStyle","beginFill","color","drawCircle","size","endFill","stage","addChild","drawPolygon","index","moveTo","lineTo","generatePoints","extent","i","push","Object","math","POINT_COMPARATOR","a","b","convexHull","newPoints","slice","sort","length","upperHull","p","q","r","pop","lowerHull","concat","makeHullPresorted","Projection","this","prototype","overlap","other","getOverlap","Shape","vertices","getAxes","axes","p1","p2","normal","subtract","perpendicular","normalization","project","axis","dot","projection","Vector","prototypeAccessors","get","sqrt","dotProduct","SAT","getMTV","shape1","shape2","let","Number","POSITIVE_INFINITY","smallest","axes1","axes2","o","mtv","colorSet","id","container","document","querySelector","width","clientWidth","height","clientHeight","Application","backgroundColor","antialias","appendChild","view","initApp","ref","screen","Matrix","generateBasis","drawGrid","points1","points2","sat_shape1","shape","map","vector","sat_shape2","console","log","sat"],"mappings":"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","file":"sat.js","sourcesContent":["/**\n * @module pg/utils/math\n */\n\n/**\n * Gets a random integer\n *\n * @param {number} min minimum number.\n * @param {number} max maximum number.\n * @return {number} The random integer number.\n * @api\n */\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Gets convex 2d numbers\n * @param {number} step step.\n * @return {array} The convex 2d numbers.\n * @api\n */\nexport function convex2d(step) {\n  const convex = [];\n\n  for (let i = 0; i < step; i++) {\n    const x = i / step;\n    convex.push([x, 1 - i / step]);\n  }\n  return convex;\n}\n\n/**\n * Rotates coordinate system for velocities\n *\n * Takes velocities and alters them as if the coordinate system they're on was rotated\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} velocity The velocity of an individual particle\n * @param {number} angle The angle of collision between two objects in radians\n * @return {Object} The altered x and y velocities after the coordinate system has been rotated\n */\nexport function rotate(velocity, angle) {\n  return {\n    x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),\n    y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)\n  };\n}\n\n/**\n * Swaps out two colliding particles' x and y velocities after running through\n * an elastic collision reaction equation\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} particle A particle object with x and y coordinates, plus velocity\n * @param {object} otherParticle A particle object with x and y coordinates, plus velocity\n * @return {boolean} success\n */\nexport function resolveCollision(particle, otherParticle) {\n  const xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;\n  const yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;\n\n  const xDist = otherParticle.x - particle.x;\n  const yDist = otherParticle.y - particle.y;\n\n  // Prevent accidental overlap of particles\n  if (xVelocityDiff * xDist + yVelocityDiff * yDist < 0) {\n    return false;\n  }\n\n  // Grab angle between the two colliding particles\n  const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);\n\n  // Store mass in var for better readability in collision equation\n  const m1 = particle.mass;\n  const m2 = otherParticle.mass;\n\n  // Velocity before equation\n  const u1 = rotate(particle.velocity, angle);\n  const u2 = rotate(otherParticle.velocity, angle);\n\n  // Velocity after 1d collision equation\n  const v1 = {x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y};\n  const v2 = {x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y};\n\n  // Final velocity after rotating axis back to original location\n  const vFinal1 = rotate(v1, -angle);\n  const vFinal2 = rotate(v2, -angle);\n\n  // Swap particle velocities for realistic bounce effect\n  particle.velocity.x = vFinal1.x;\n  particle.velocity.y = vFinal1.y;\n\n  otherParticle.velocity.x = vFinal2.x;\n  otherParticle.velocity.y = vFinal2.y;\n  return true;\n}\n","export function initApp(id) {\n  const container = document.querySelector(id);\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n  const app = new PIXI.Application(width, height, {backgroundColor: 0x282a36, antialias: true});\n\n  container.appendChild(app.view);\n  return app;\n}\n\nexport function generateBasis(app) {\n  const {width, height} = app.screen;\n  return new PIXI.Matrix(1, 0, 0, -1, width * 0.5, height * 0.5);\n}\n\nexport function drawGrid(app) {\n  const graphics = new PIXI.Graphics();\n  const {width, height} = app.screen;\n\n  graphics.lineStyle(1, 0xf8f8f2, 1);\n  graphics.moveTo(0, height * 0.5);\n  graphics.lineTo(width, height * 0.5);\n  graphics.moveTo(width * 0.5, 0);\n  graphics.lineTo(width * 0.5, height);\n\n  app.stage.addChild(graphics);\n}\n\nexport function drawPoints(app, basis, points, style) {\n  const graphics = new PIXI.Graphics();\n\n  points.forEach(point => {\n    point = new PIXI.Point(point.x, point.y);\n    point = basis.apply(point);\n\n    graphics.lineStyle(0);\n    graphics.beginFill(style.color, 1);\n    graphics.drawCircle(point.x, point.y, style.size);\n    graphics.endFill();\n  });\n  app.stage.addChild(graphics);\n}\n\nexport function drawPolygon(app, basis, points, style) {\n  const graphics = new PIXI.Graphics();\n\n  graphics.lineStyle(1, style.color, 1);\n  graphics.beginFill(style.color, 0.3);\n\n  points.forEach((point, index) => {\n    point = new PIXI.Point(point.x, point.y);\n    point = basis.apply(point);\n\n    if (index === 0) {\n      graphics.moveTo(point.x, point.y);\n    } else {\n      graphics.lineTo(point.x, point.y);\n    }\n  });\n  graphics.endFill();\n\n  app.stage.addChild(graphics);\n}\n","import {randomInt} from \"../../../../src/pg/utils/math\";\n\nexport function generatePoints(size, extent) {\n  const points = [];\n  for (let i = 0; i < size; i++) {\n    points.push({\n      x: randomInt(extent[0], extent[2]),\n      y: randomInt(extent[1], extent[3]),\n    });\n  }\n  return points;\n}\n\n","/*\n * Convex hull algorithm - Library (JavaScript)\n *\n * Copyright (c) 2018 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nfunction POINT_COMPARATOR(a, b) {\n  if (a.x < b.x) return -1;\n  else if (a.x > b.x) return +1;\n  else if (a.y < b.y) return -1;\n  else if (a.y > b.y) return +1;\n  else return 0;\n}\n\n// Returns a new array of points representing the convex hull of\n// the given set of points. The convex hull excludes collinear points.\n// This algorithm runs in O(n log n) time.\nexport default function convexHull(points) {\n  const newPoints = points.slice();\n  newPoints.sort(POINT_COMPARATOR);\n  return makeHullPresorted(newPoints);\n}\n\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nfunction makeHullPresorted(points) {\n  if (points.length <= 1) {\n    return points.slice();\n  }\n\n  // Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n  // as per the mathematical convention, instead of \"down\" as per the computer\n  // graphics convention. This doesn't affect the correctness of the result.\n\n  const upperHull = [];\n\n  const length = points.length;\n  for (let i = 0; i < length; i++) {\n    const p = points[i];\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n        upperHull.pop();\n      } else {\n        break;\n      }\n    }\n    upperHull.push(p);\n  }\n  upperHull.pop();\n\n  const lowerHull = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n        lowerHull.pop();\n      } else {\n        break;\n      }\n    }\n    lowerHull.push(p);\n  }\n  lowerHull.pop();\n\n  if (\n    upperHull.length === 1 &&\n    lowerHull.length === 1 &&\n    upperHull[0].x === lowerHull[0].x &&\n    upperHull[0].y === lowerHull[0].y\n  ) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\n\n\n","export default class Projection {\n  constructor(min, max) {\n    this.min = min;\n    this.max = max;\n  }\n\n  overlap(other) {\n    return this.max > other.min && other.max > this.min;\n  }\n\n  getOverlap(other) {\n    let overlap;\n\n    if (!this.overlap(other)) {\n      return 0;\n    }\n\n    if (this.max > other.max) {\n      overlap = other.max - this.min;\n    } else {\n      overlap = this.max - other.min;\n    }\n\n    return overlap;\n  }\n}\n","import Projection from './projection';\n\nexport default class Shape {\n\n  constructor(vertices) {\n    this.vertices = vertices;\n  }\n\n  getAxes() {\n    const axes = [];\n    const length = this.vertices.length;\n\n    // loop over the vertices\n    for (let i = 0; i < length; i++) {\n      // get the current vertex\n      const p1 = this.vertices[i];\n      // get the next vertex\n      const p2 = this.vertices[i + 1 === length ? 0 : i + 1];\n      // subtract the two to get the edge vector\n      const edge = p1.subtract(p2);\n      // get either perpendicular vector\n      const normal = edge.perpendicular().normalization();\n      // the perp method is just (x, y) => (-y, x) or (y, -x)\n      axes.push(normal);\n    }\n    return axes;\n  }\n\n  project(axis) {\n    let min = axis.dot(this.vertices[0]);\n    let max = min;\n    const length = this.vertices.length;\n\n    for (let i = 1; i < length; i++) {\n      // NOTE: the axis must be normalized to get accurate projections\n      const p = axis.dot(this.vertices[i]);\n      if (p < min) {\n        min = p;\n      } else if (p > max) {\n        max = p;\n      }\n    }\n\n    return new Projection(min, max);\n  }\n}\n","import {dotProduct} from './utils';\n\nexport default class Vector {\n  get length() {\n    return Math.sqrt(this.x * this. x + this.y * this.y);\n  }\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  subtract(other) {\n    return new Vector(\n      this.x - other.x,\n      this.y - other.y,\n    );\n  }\n\n  perpendicular() {\n    return new Vector(-this.y, this.x);\n  }\n\n  dot(other) {\n    return dotProduct(this, other);\n  }\n\n  normalization() {\n    const length = this.length;\n    return new Vector(this.x / length, this.y / length);\n  }\n}\n","export function dotProduct(v1, v2) {\n  return v1.x * v2.x + v1.y * v2.y;\n}\n","export default class MTV {\n  constructor(axis, overlap) {\n    this.axis = axis;\n    this.overlap = overlap;\n  }\n}\n","import MTV from '../2d/mtv';\n\nexport default class SAT {\n  static getMTV(shape1, shape2) { // Minimum Translation Vector\n    let overlap = Number.POSITIVE_INFINITY;\n    let smallest = null;\n    const axes1 = shape1.getAxes();\n    const axes2 = shape2.getAxes();\n\n    // loop over the axes1\n    for (let i = 0; i < axes1.length; i++) {\n      const axis = axes1[i];\n      // project both shapes onto the axis\n      const p1 = shape1.project(axis);\n      const p2 = shape2.project(axis);\n\n      // do the projections overlap?\n      if (!p1.overlap(p2)) {\n        // then we can guarantee that the shapes do not overlap\n        return null;\n      } else {\n        // get the overlap\n        const o = p1.getOverlap(p2);\n        // check for minimum\n        if (o < overlap) {\n          // then set this one as the smallest\n          overlap = o;\n          smallest = axis;\n        }\n      }\n    }\n\n    // loop over the axes2\n    for (let i = 0; i < axes2.length; i++) {\n      const axis = axes2[i];\n      // project both shapes onto the axis\n      const p1 = shape1.project(axis);\n      const p2 = shape2.project(axis);\n\n      // do the projections overlap?\n      if (!p1.overlap(p2)) {\n        // then we can guarantee that the shapes do not overlap\n        return null;\n      } else {\n        // get the overlap\n        const o = p1.getOverlap(p2);\n        // check for minimum\n        if (o < overlap) {\n          // then set this one as the smallest\n          overlap = o;\n          smallest = axis;\n        }\n      }\n    }\n\n    // if we get here then we know that every axis had overlap on it\n    // so we can guarantee an intersection\n    return new MTV(smallest, overlap);\n  }\n}\n\n","import {\n  drawGrid,\n  drawPoints,\n  drawPolygon,\n  generateBasis,\n  initApp\n} from './utils/graphics/pixi/utils';\nimport {generatePoints} from './utils/graphics/pixi/figure';\nimport convexHull from './utils/graphics/2d/convex-hull';\nimport Shape from './utils/graphics/2d/shape';\nimport Vector from './utils/graphics/2d/vector';\nimport SAT from './utils/graphics/collision/sat';\n\nconst colorSet = [\n  0x8be9fd,\n  0x50fa7b,\n  0xffb86c,\n  0xff79c6,\n  0xbd93f9,\n  0xff5555,\n  0xf1fa8c,\n];\nconst app = initApp('#container');\nconst basis = generateBasis(app);\n\ndrawGrid(app);\n\nconst points1 = convexHull(generatePoints(5, [-150, -50, 300,100]));\nconst points2 = convexHull(generatePoints(5, [-300, -100, 150,50]));\n\ndrawPoints(app, basis, points1,{color: colorSet[1], size: 3});\ndrawPoints(app, basis, points2, {color: colorSet[5], size: 3});\ndrawPolygon(app, basis, [...points1, points1[0]], {color: colorSet[1], size: 3});\ndrawPolygon(app, basis, [...points2, points2[0]], {color: colorSet[5], size: 3});\n\nconst shape1 = new Shape(points1.map(p => new Vector(p.x, p.y)));\nconst shape2 = new Shape(points2.map(p => new Vector(p.x, p.y)));\nconsole.log(\n  SAT.getMTV(shape1, shape2)\n);\n"],"sourceRoot":""}