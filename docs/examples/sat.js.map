{"version":3,"sources":["webpack:///../src/pg/utils/math.js","webpack:///./utils/pixi/utils.js","webpack:///./utils/pixi/figure.js","webpack:///./utils/convex-hull.js","webpack:///./sat.js"],"names":["randomInt","min","max","Math","floor","random","rotate","velocity","angle","x","cos","y","sin","resolveCollision","particle","otherParticle","const","xVelocityDiff","yVelocityDiff","atan2","m1","mass","m2","u1","u2","v1","v2","vFinal1","vFinal2","__webpack_require__","d","__webpack_exports__","drawPoints","app","basis","points","style","graphics","PIXI","Graphics","forEach","point","Point","apply","lineStyle","beginFill","color","drawCircle","size","endFill","stage","addChild","drawPolygon","index","moveTo","lineTo","generatePoints","extent","i","push","Object","math","POINT_COMPARATOR","a","b","convexHull","newPoints","slice","sort","length","upperHull","p","q","r","pop","lowerHull","concat","makeHullPresorted","colorSet","id","container","document","querySelector","width","clientWidth","height","clientHeight","Application","backgroundColor","antialias","appendChild","view","initApp","ref","screen","Matrix","generateBasis","drawGrid","points1","points2"],"mappings":"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","file":"sat.js","sourcesContent":["/**\n * @module pg/utils/math\n */\n\n/**\n * Gets a random integer\n *\n * @param {number} min minimum number.\n * @param {number} max maximum number.\n * @return {number} The random integer number.\n * @api\n */\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Gets convex 2d numbers\n * @param {number} step step.\n * @return {array} The convex 2d numbers.\n * @api\n */\nexport function convex2d(step) {\n  const convex = [];\n\n  for (let i = 0; i < step; i++) {\n    const x = i / step;\n    convex.push([x, 1 - i / step]);\n  }\n  return convex;\n}\n\n/**\n * Rotates coordinate system for velocities\n *\n * Takes velocities and alters them as if the coordinate system they're on was rotated\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} velocity The velocity of an individual particle\n * @param {number} angle The angle of collision between two objects in radians\n * @return {Object} The altered x and y velocities after the coordinate system has been rotated\n */\nexport function rotate(velocity, angle) {\n  return {\n    x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),\n    y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)\n  };\n}\n\n/**\n * Swaps out two colliding particles' x and y velocities after running through\n * an elastic collision reaction equation\n *\n * {@link https://gist.github.com/christopher4lis/f9ccb589ee8ecf751481f05a8e59b1dc}\n *\n * @param {object} particle A particle object with x and y coordinates, plus velocity\n * @param {object} otherParticle A particle object with x and y coordinates, plus velocity\n * @return {boolean} success\n */\nexport function resolveCollision(particle, otherParticle) {\n  const xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;\n  const yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;\n\n  const xDist = otherParticle.x - particle.x;\n  const yDist = otherParticle.y - particle.y;\n\n  // Prevent accidental overlap of particles\n  if (xVelocityDiff * xDist + yVelocityDiff * yDist < 0) {\n    return false;\n  }\n\n  // Grab angle between the two colliding particles\n  const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);\n\n  // Store mass in var for better readability in collision equation\n  const m1 = particle.mass;\n  const m2 = otherParticle.mass;\n\n  // Velocity before equation\n  const u1 = rotate(particle.velocity, angle);\n  const u2 = rotate(otherParticle.velocity, angle);\n\n  // Velocity after 1d collision equation\n  const v1 = {x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y};\n  const v2 = {x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y};\n\n  // Final velocity after rotating axis back to original location\n  const vFinal1 = rotate(v1, -angle);\n  const vFinal2 = rotate(v2, -angle);\n\n  // Swap particle velocities for realistic bounce effect\n  particle.velocity.x = vFinal1.x;\n  particle.velocity.y = vFinal1.y;\n\n  otherParticle.velocity.x = vFinal2.x;\n  otherParticle.velocity.y = vFinal2.y;\n  return true;\n}\n","export function initApp(id) {\n  const container = document.querySelector(id);\n  const width = container.clientWidth;\n  const height = container.clientHeight;\n  const app = new PIXI.Application(width, height, {backgroundColor: 0x282a36, antialias: true});\n\n  container.appendChild(app.view);\n  return app;\n}\n\nexport function generateBasis(app) {\n  const {width, height} = app.screen;\n  return new PIXI.Matrix(1, 0, 0, -1, width * 0.5, height * 0.5);\n}\n\nexport function drawGrid(app) {\n  const graphics = new PIXI.Graphics();\n  const {width, height} = app.screen;\n\n  graphics.lineStyle(1, 0xf8f8f2, 1);\n  graphics.moveTo(0, height * 0.5);\n  graphics.lineTo(width, height * 0.5);\n  graphics.moveTo(width * 0.5, 0);\n  graphics.lineTo(width * 0.5, height);\n\n  app.stage.addChild(graphics);\n}\n\nexport function drawPoints(app, basis, points, style) {\n  const graphics = new PIXI.Graphics();\n\n  points.forEach(point => {\n    point = new PIXI.Point(point.x, point.y);\n    point = basis.apply(point);\n\n    graphics.lineStyle(0);\n    graphics.beginFill(style.color, 1);\n    graphics.drawCircle(point.x, point.y, style.size);\n    graphics.endFill();\n  });\n  app.stage.addChild(graphics);\n}\n\nexport function drawPolygon(app, basis, points, style) {\n  const graphics = new PIXI.Graphics();\n\n  graphics.lineStyle(1, style.color, 1);\n  graphics.beginFill(style.color, 0.3);\n\n  points.forEach((point, index) => {\n    point = new PIXI.Point(point.x, point.y);\n    point = basis.apply(point);\n\n    if (index === 0) {\n      graphics.moveTo(point.x, point.y);\n    } else {\n      graphics.lineTo(point.x, point.y);\n    }\n  });\n  graphics.endFill();\n\n  app.stage.addChild(graphics);\n}\n","import {randomInt} from \"../../../src/pg/utils/math\";\n\nexport function generatePoints(size, extent) {\n  const points = [];\n  for (let i = 0; i < size; i++) {\n    points.push({\n      x: randomInt(extent[0], extent[2]),\n      y: randomInt(extent[1], extent[3]),\n    });\n  }\n  return points;\n}\n\n","/*\n * Convex hull algorithm - Library (JavaScript)\n *\n * Copyright (c) 2018 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nfunction POINT_COMPARATOR(a, b) {\n  if (a.x < b.x) return -1;\n  else if (a.x > b.x) return +1;\n  else if (a.y < b.y) return -1;\n  else if (a.y > b.y) return +1;\n  else return 0;\n}\n\n// Returns a new array of points representing the convex hull of\n// the given set of points. The convex hull excludes collinear points.\n// This algorithm runs in O(n log n) time.\nexport default function convexHull(points) {\n  const newPoints = points.slice();\n  newPoints.sort(POINT_COMPARATOR);\n  return makeHullPresorted(newPoints);\n}\n\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nfunction makeHullPresorted(points) {\n  if (points.length <= 1) {\n    return points.slice();\n  }\n\n  // Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n  // as per the mathematical convention, instead of \"down\" as per the computer\n  // graphics convention. This doesn't affect the correctness of the result.\n\n  const upperHull = [];\n\n  const length = points.length;\n  for (let i = 0; i < length; i++) {\n    const p = points[i];\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n        upperHull.pop();\n      } else {\n        break;\n      }\n    }\n    upperHull.push(p);\n  }\n  upperHull.pop();\n\n  const lowerHull = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n        lowerHull.pop();\n      } else {\n        break;\n      }\n    }\n    lowerHull.push(p);\n  }\n  lowerHull.pop();\n\n  if (\n    upperHull.length === 1 &&\n    lowerHull.length === 1 &&\n    upperHull[0].x === lowerHull[0].x &&\n    upperHull[0].y === lowerHull[0].y\n  ) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\n\n\n","import {\n  drawGrid,\n  drawPoints,\n  drawPolygon,\n  generateBasis,\n  initApp\n} from './utils/pixi/utils';\nimport {generatePoints} from './utils/pixi/figure';\nimport convexHull from \"./utils/convex-hull\";\n\nconst colorSet = [\n  0x8be9fd,\n  0x50fa7b,\n  0xffb86c,\n  0xff79c6,\n  0xbd93f9,\n  0xff5555,\n  0xf1fa8c,\n];\nconst app = initApp('#container');\nconst basis = generateBasis(app);\n\ndrawGrid(app);\n\nconst points1 = convexHull(generatePoints(5, [-150, -50, 300,100]));\nconst points2 = convexHull(generatePoints(5, [-300, -100, 150,50]));\n\ndrawPoints(app, basis, points1,{color: colorSet[1], size: 3});\ndrawPoints(app, basis, points2, {color: colorSet[5], size: 3});\ndrawPolygon(app, basis, [...points1, points1[0]], {color: colorSet[1], size: 3});\ndrawPolygon(app, basis, [...points2, points2[0]], {color: colorSet[5], size: 3});\n"],"sourceRoot":""}