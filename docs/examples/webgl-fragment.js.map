{"version":3,"sources":["webpack:///./webgl-fragment.js"],"names":["let","gl","canvas","container","glProgram","fragmentShader","vertexShader","vertexPositionAttribute","trianglesVerticeBuffer","vertexIndexBuffer","SHADER","circle","circle_floor","circle_uniform_1","circle_uniform_2","mandelbrot","julia_1","julia_2","radios","document","querySelectorAll","changeHandler","deleteProgram","createProgram","this","value","type","const","vsSource","fsSource","makeShader","VERTEX_SHADER","FRAGMENT_SHADER","attachShader","linkProgram","getProgramParameter","LINK_STATUS","alert","useProgram","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","window","addEventListener","querySelector","width","clientWidth","height","clientHeight","getContext","e","console","error","size","vertexPositionData","indexData","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","itemSize","numItems","length","ELEMENT_ARRAY_BUFFER","Uint16Array","STREAM_DRAW","createSquare","colors","Uint8Array","colorsTexture","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","uniform1i","getUniformLocation","setUniforms","getAttribLocation","enableVertexAttribArray","animLoop","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","DEPTH_TEST","viewport","vertexAttribPointer","FLOAT","drawElements","TRIANGLES","UNSIGNED_SHORT","requestAnimationFrame","Array","prototype","forEach","call","radio"],"mappings":"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","file":"webgl-fragment.js","sourcesContent":["let gl = null;\nlet canvas = null;\nlet container = null;\nlet glProgram = null;\nlet fragmentShader = null;\nlet vertexShader = null;\n\nlet vertexPositionAttribute = null;\nlet trianglesVerticeBuffer = null;\nlet vertexIndexBuffer = null;\n\nconst SHADER = {\n  circle: {\n    vertexShader: circleVertexShaderSource(),\n    fragmentShader: circleFragmentShaderSource()\n  },\n  circle_floor: {\n    vertexShader: circleFloorVertexShaderSource(),\n    fragmentShader: circleFloorFragmentShaderSource()\n  },\n  circle_uniform_1: {\n    vertexShader: circleUniform1VertexShaderSource(),\n    fragmentShader: circleUniform1FragmentShaderSource()\n  },\n  circle_uniform_2: {\n    vertexShader: circleUniform2VertexShaderSource(),\n    fragmentShader: circleUniform2FragmentShaderSource()\n  },\n  mandelbrot:  {\n    vertexShader: mandelbrotVertexShaderSource(),\n    fragmentShader: mandelbrotFragmentShaderSource()\n  },\n  julia_1:  {\n    vertexShader: julia1VertexShaderSource(),\n    fragmentShader: julia1FragmentShaderSource()\n  },\n  julia_2:  {\n    vertexShader: julia2VertexShaderSource(),\n    fragmentShader: julia2FragmentShaderSource()\n  },\n};\n\nconst radios = document.querySelectorAll('input[type=radio][name=\"fragment\"]');\n\nwindow.addEventListener('load', initWebGL);\n\nfunction changeHandler() {\n  gl.deleteProgram(glProgram);\n  createProgram(this.value);\n}\n\nArray.prototype.forEach.call(radios, function (radio) {\n  radio.addEventListener('change', changeHandler);\n});\n\nfunction initWebGL() {\n  canvas = document.querySelector('#canvas');\n  container = document.querySelector('#container');\n  canvas.width = container.clientWidth;\n  canvas.height = container.clientHeight;\n\n  try {\n    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  } catch (e) {\n    console.error(e);\n  }\n\n  if (gl) {\n    initShaders();\n    createSquare();\n    setUniforms();\n\n    vertexPositionAttribute = gl.getAttribLocation(glProgram, \"aVertexPosition\");\n    gl.enableVertexAttribArray(vertexPositionAttribute);\n\n    (function animLoop() {\n      setupWebGL();\n      drawScene();\n\n      requestAnimationFrame(animLoop);\n    })();\n  }\n}\n\nfunction setupWebGL() {\n  // set the clear color to a shade of green\n  gl.clearColor(0.7, 0.7, 0.7, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.enable(gl.DEPTH_TEST);\n\n  gl.viewport(0, 0, canvas.width, canvas.height);\n}\n\nfunction initShaders() {\n  createProgram('circle');\n}\n\nfunction createProgram(type) {\n  // create program\n  glProgram = gl.createProgram();\n  attachShader(glProgram, type);\n  // use program\n  gl.useProgram(glProgram);\n}\n\nfunction attachShader(glProgram, type) {\n  // get shader source\n  const vsSource = SHADER[type].vertexShader;\n  const fsSource = SHADER[type].fragmentShader;\n\n  // compile shaders\n  vertexShader = makeShader(vsSource, gl.VERTEX_SHADER);\n  fragmentShader = makeShader(fsSource, gl.FRAGMENT_SHADER);\n\n  // attach and link shaders to the program\n  gl.attachShader(glProgram, vertexShader);\n  gl.attachShader(glProgram, fragmentShader);\n  gl.linkProgram(glProgram);\n\n  if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n    alert('Unable to initialize the shader program.');\n  }\n}\n\nfunction makeShader(source, type) {\n  // compile the shader\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);\n  }\n\n  return shader;\n}\n\nfunction drawScene() {\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);\n  gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);\n  gl.drawElements(gl.TRIANGLES, vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n}\n\nfunction createSquare(size = 2.0) {\n  const vertexPositionData = [\n    0.0, 0.0, 0.0,\n    -size / 2.0, -size / 2.0, 0.0,\n    size / 2.0, -size / 2.0, 0.0,\n    size / 2.0, size / 2.0, 0.0,\n    -size / 2.0, size / 2.0, 0.0,\n  ];\n  const indexData = [0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 1];\n\n  trianglesVerticeBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trianglesVerticeBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);\n  trianglesVerticeBuffer.itemSize = 3;\n  trianglesVerticeBuffer.numItems = vertexPositionData.length / 3;\n  vertexIndexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);\n  vertexIndexBuffer.itemSize = 3;\n  vertexIndexBuffer.numItems = indexData.length;\n}\n\nfunction setUniforms() {\n  const colorData = [\n    255, 0, 0, 255,\n    255, 0, 0, 255,\n    255, 0, 0, 255,\n    255, 0, 0, 255,\n    255, 255, 0, 255,\n    255, 255, 0, 255,\n    255, 255, 0, 255,\n    255, 255, 0, 255,\n    0, 255, 0, 255,\n    0, 255, 0, 255,\n    0, 255, 0, 255,\n    0, 255, 0, 255,\n    0, 0, 255, 255,\n    0, 0, 255, 255,\n    0, 0, 255, 255,\n    0, 0, 255, 255\n  ];\n  const colors = new Uint8Array(colorData);\n  const colorsTexture = gl.createTexture();\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(gl.TEXTURE_2D, colorsTexture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4, 4, 0,\n    gl.RGBA, gl.UNSIGNED_BYTE, colors);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.uniform1i(gl.getUniformLocation(glProgram, \"sColors\"), colorsTexture);\n}\n\nfunction circleVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    varying vec2 position;\n    \n    void main(void) {\n      position = vec2(aVertexPosition.xy);\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction circleFragmentShaderSource() {\n  return `\n    varying highp vec2 position;\n    \n    void main(void) {   \n      highp float d = length(position);\n      gl_FragColor = vec4(max(0.0, 1.0 - d), 0.0, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction circleFloorVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    varying vec2 position;\n    \n    void main(void) {\n      position = vec2(aVertexPosition.xy);\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction circleFloorFragmentShaderSource() {\n  return `\n    varying highp vec2 position;\n    \n    void main(void) {   \n      highp float d = length(position);\n      highp float c = floor(d*10.0) * 0.1;\n      gl_FragColor = vec4(max(0.0, 1.0 - c), 0.0, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction circleUniform1VertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    varying vec2 position;\n    \n    void main(void) {\n      position = vec2(aVertexPosition.xy);\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction circleUniform1FragmentShaderSource() {\n  return `\n    uniform sampler2D sColors;\n    varying highp vec2 position;\n    \n    void main(void) {   \n      highp float t = length(position);\n      gl_FragColor = vec4(texture2D(sColors, vec2(0.0, t)).rgb, 1.0);\n    }\n  `;\n}\n\nfunction circleUniform2VertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    varying vec2 position;\n    \n    void main(void) {\n      position = vec2(aVertexPosition.xy);\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction circleUniform2FragmentShaderSource() {\n  return `\n    uniform sampler2D sColors;\n    varying highp vec2 position;\n    \n    void main(void) {   \n      highp float t = length(position);\n      highp float x = sin(-position.y) * tan(length(position.xx));\n      t = t + x;\n      gl_FragColor = mix( vec4(0.0, 0.0, 0.0, 1.0), vec4(texture2D(sColors, vec2(0.0, t)).rgb, 1.0), t);\n    }\n  `;\n}\n\nfunction mandelbrotVertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    varying vec2 position;\n    \n    void main(void) {\n      position = vec2(aVertexPosition.xy);\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction mandelbrotFragmentShaderSource() {\n  return `\n    varying highp vec2 position;\n    const int MAX_ITERATIONS = 250;\n    const highp float LIGHTNESS_FACTOR = 10.0;\n    \n    void main(void) {   \n      highp vec2 c = vec2(position.x - 0.5, position.y); \n      highp vec2 z = c;\n      \n      highp vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n      \n      for (int i = 0; i < MAX_ITERATIONS; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        \n        if (dot(z, z) > 4.0) {\n          highp float f = LIGHTNESS_FACTOR * float(i) / float(MAX_ITERATIONS);\n          color = vec4(vec3(0.1, 0.1, 1.0) * f , 1.0);\n          break;\n        }\n      }\n      gl_FragColor = color;\n    }\n  `;\n}\n\nfunction julia1VertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    varying vec2 position;\n    \n    void main(void) {\n      position = vec2(aVertexPosition.xy);\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction julia1FragmentShaderSource() {\n  return `\n    varying highp vec2 position;\n    const int MAX_ITERATIONS = 250;\n    const highp float LIGHTNESS_FACTOR = 10.0;\n    \n    void main(void) {   \n      highp vec2 z = vec2(position.x, position.y);\n      highp vec2 c = vec2(-.8,-.2);\n      \n      highp vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n      \n      for (int i = 0; i < MAX_ITERATIONS; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        \n        if (dot(z, z) > 4.0) {\n          highp float f = LIGHTNESS_FACTOR * float(i) / float(MAX_ITERATIONS);\n          color = vec4(vec3(0.1, 0.1, 1.0) * f , 1.0);\n          break;\n        }\n      }\n      gl_FragColor = color;\n    }\n  `;\n}\n\nfunction julia2VertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    varying vec2 position;\n    \n    void main(void) {\n      position = vec2(aVertexPosition.xy);\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n}\n\nfunction julia2FragmentShaderSource() {\n  return `\n    varying highp vec2 position;\n    const int MAX_ITERATIONS = 250;\n    const highp float LIGHTNESS_FACTOR = 10.0;\n    \n    void main(void) {   \n      highp vec2 z = vec2(position.x, position.y);\n      highp vec2 c = vec2(-.5,-.62);\n      \n      highp vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n      \n      for (int i = 0; i < MAX_ITERATIONS; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        \n        if (dot(z, z) > 4.0) {\n          highp float f = LIGHTNESS_FACTOR * float(i) / float(MAX_ITERATIONS);\n          color = vec4(vec3(0.1, 0.1, 1.0) * f , 1.0);\n          break;\n        }\n      }\n      gl_FragColor = color;\n    }\n  `;\n}\n\n"],"sourceRoot":""}