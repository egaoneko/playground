{"version":3,"sources":["webpack:///./webgl-optimize-2.js"],"names":["let","gl","canvas","container","glProgram","fragmentShader","vertexShader","vertexPositionAttribute","vertexNormalAttribute","vertexTexCoordAttribute","trianglesInterleavedBuffers","vertexIndexBuffers","spherePositions","textures","textureImages","textureFilenames","topHalf","i","length","pMatrix","mat4","create","mvMatrix","normalMatrix","mat3","num_spheres","paused","SpherePosition","this","x_offset_orig","Math","random","y_offset_orig","z_offset_orig","x_offset","y_offset","z_offset","x_angle","y_angle","z_angle","angle","radius","push","makeShader","source","type","const","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","setMvMatrix","sp","identity","translate","rotate","invertedMatrix","fromMat4","invert","transpose","cos","sin","setMatrixUniforms","uniformMatrix4fv","mvMatrixUniform","uniformMatrix3fv","normalMatrixUniform","loadTexture","Image","onload","activeTexture","TEXTURE0","createTexture","bindTexture","TEXTURE_2D","pixelStorei","UNPACK_FLIP_Y_WEBGL","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","isTexture","console","error","setupTexture","src","window","addEventListener","document","querySelector","width","clientWidth","height","clientHeight","getContext","e","vsSource","fsSource","VERTEX_SHADER","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","initShaders","tex_scale_y","tex_start_y","active_num","indexOf","interleavedData","indexData","latNumber","theta","PI","sinTheta","cosTheta","longNumber","phi","sinPhi","cosPhi","x","y","z","u","v","first","second","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","itemSize","numItems","ELEMENT_ARRAY_BUFFER","Uint16Array","STREAM_DRAW","setupSphereData","pMatrixUniform","getUniformLocation","samplerUniform","uniform1i","loadTextures","viewport","perspective","getAttribLocation","enableVertexAttribArray","animLoop","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","DEPTH_TEST","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawElements","TRIANGLES","UNSIGNED_SHORT","drawScene","requestAnimationFrame","evt","keyCode"],"mappings":"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","file":"webgl-optimize-2.js","sourcesContent":["let gl = null;\nlet canvas = null;\nlet container = null;\nlet glProgram = null;\nlet fragmentShader = null;\nlet vertexShader = null;\n\nlet vertexPositionAttribute = null;\nlet vertexNormalAttribute = null;\nlet vertexTexCoordAttribute = null;\nconst trianglesInterleavedBuffers = [];\nconst vertexIndexBuffers = [];\n\nconst spherePositions = [];\nconst textures = [];\nconst textureImages = [];\nconst textureFilenames = [\n  'sun.png',\n  'earth.jpg',\n  'mars.jpg',\n  'moon.jpg',\n  'jupiter.jpg',\n  'saturn.jpg',\n];\nconst topHalf = [1, 2, 4, 5];\nconst texture_directory = 'data/img/';\n\nfor (let i = 0; i < textureFilenames.length; ++i) {\n  textureFilenames[i] = texture_directory + textureFilenames[i];\n}\n\nlet pMatrix = mat4.create();\nlet mvMatrix = mat4.create();\nlet normalMatrix = mat3.create();\n\nconst num_spheres = 1500;\nlet paused = false;\n\nclass SpherePosition {\n  constructor() {\n    this.x_offset_orig = 10.0 - Math.random() * 20.0;\n    this.y_offset_orig = 10.0 - Math.random() * 20.0;\n    this.z_offset_orig = -25.0 + Math.random() * 12.0;\n\n    this.x_offset = this.x_offset_orig;\n    this.y_offset = this.y_offset_orig;\n    this.z_offset = this.z_offset_orig;\n\n    this.x_angle = Math.random() * 360;\n    this.y_angle = Math.random() * 360;\n    this.z_angle = Math.random() * 360;\n    this.angle = 0.005;\n    this.radius = 0.1 + Math.random() * .2;\n  }\n}\n\nfor (let i = 0; i < num_spheres; ++i) {\n  spherePositions.push(new SpherePosition());\n}\n\nwindow.addEventListener('load', initWebGL);\ndocument.addEventListener('keyup', (evt) => {\n  switch (evt.keyCode) {\n    case 80: // 'p'\n      paused = !paused;\n      break;\n  }\n});\n\nfunction initWebGL() {\n  canvas = document.querySelector('#canvas');\n  container = document.querySelector('#container');\n  canvas.width = container.clientWidth;\n  canvas.height = container.clientHeight;\n\n  try {\n    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  } catch (e) {\n    console.error(e);\n  }\n\n  if (gl) {\n    initShaders();\n    setupSphereData();\n\n    getMatrixUniforms();\n    loadTextures();\n\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    mat4.perspective(pMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);\n    gl.uniformMatrix4fv(glProgram.pMatrixUniform, false, pMatrix);\n    vertexPositionAttribute = gl.getAttribLocation(glProgram, 'aVertexPosition');\n    vertexNormalAttribute = gl.getAttribLocation(glProgram, 'aVertexNormal');\n    vertexTexCoordAttribute = gl.getAttribLocation(glProgram, 'aVertexTexCoord');\n    gl.enableVertexAttribArray(vertexPositionAttribute);\n    gl.enableVertexAttribArray(vertexNormalAttribute);\n    gl.enableVertexAttribArray(vertexTexCoordAttribute);\n\n\n    (function animLoop() {\n\n      if (!paused) {\n        setupWebGL();\n        drawScene();\n      }\n\n      requestAnimationFrame(animLoop);\n    })();\n  }\n}\n\nfunction setupWebGL() {\n  // set the clear color to a shade of green\n  gl.clearColor(0.1, 0.5, 0.1, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.enable(gl.DEPTH_TEST);\n}\n\nfunction initShaders() {\n  // get shader source\n  const vsSource = vertexShaderSource();\n  const fsSource = fragmentShaderSource();\n\n  // compile shaders\n  vertexShader = makeShader(vsSource, gl.VERTEX_SHADER);\n  fragmentShader = makeShader(fsSource, gl.FRAGMENT_SHADER);\n\n  // create program\n  glProgram = gl.createProgram();\n\n  // attach and link shaders to the program\n  gl.attachShader(glProgram, vertexShader);\n  gl.attachShader(glProgram, fragmentShader);\n  gl.linkProgram(glProgram);\n\n  if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n    alert('Unable to initialize the shader program.');\n  }\n\n  // use program\n  gl.useProgram(glProgram);\n}\n\nfunction makeShader(source, type) {\n  // compile the shader\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);\n  }\n\n  return shader;\n}\n\nfunction vertexShaderSource() {\n  return `\n    attribute vec3 aVertexPosition;\n    attribute vec3 aVertexNormal;\n    attribute vec2 aVertexTexCoord;\n    \n    uniform mat3 uNormalMatrix;\n    uniform mat4 uMVMatrix;\n    uniform mat4 uPMatrix;\n    \n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    void main(void) {\n      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n      vTextureCoord = aVertexTexCoord;\n      \n      vec3 pointLightPosition = vec3(1.0,2.0,-1.0);\n      vec3 pointLightDirection = normalize(vec3(pointLightPosition.xyz - aVertexPosition.xyz));\n       \n      vec3 L = vec3(uPMatrix * uMVMatrix * vec4(pointLightDirection, 1.0));\n      vec3 N = uNormalMatrix * aVertexNormal;\n      float lambert = max(dot(normalize(N), normalize(L)), 0.0);\n      vLight = 0.1 + lambert;\n    }\n  `;\n}\n\nfunction fragmentShaderSource() {\n  return `\n    varying highp float vLight;\n    varying highp vec2 vTextureCoord;\n    \n    uniform sampler2D uSampler;\n    \n    void main(void) {\n      highp vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.st));\n      gl_FragColor = vec4(textureColor.xyz * vLight, textureColor.a);\n    }\n  `;\n}\n\nfunction setMvMatrix(sp) {\n  mat4.identity(mvMatrix);\n  mat4.identity(normalMatrix);\n  mat4.translate(mvMatrix, mvMatrix, [sp.x_offset, sp.y_offset, sp.z_offset]);\n  mat4.rotate(mvMatrix, mvMatrix, sp.angle, [sp.x_angle, sp.y_angle, sp.z_angle]);\n\n  const invertedMatrix = mat3.create();\n  mat3.fromMat4(invertedMatrix, mvMatrix);\n  mat3.invert(normalMatrix, invertedMatrix);\n  mat3.transpose(normalMatrix, normalMatrix);\n\n  sp.x_angle += Math.random();\n  sp.y_angle += Math.random();\n  sp.z_angle += Math.random();\n  sp.x_offset = (Math.cos(sp.angle) * sp.x_offset_orig);\n  sp.y_offset = (Math.sin(sp.angle) * sp.y_offset_orig);\n  sp.z_offset = -25.0 + 12.0 * Math.sin(sp.angle);\n  sp.angle += 0.005;\n}\n\nfunction drawScene() {\n  for (let i = 0; i < num_spheres; ++i) {\n    setMvMatrix(spherePositions[i]);\n    setMatrixUniforms();\n\n    const active_num = i % textures.length;\n\n    gl.activeTexture(gl.TEXTURE0 + active_num);\n    gl.uniform1i(glProgram.samplerUniform, active_num);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      3 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false,\n      8 * Float32Array.BYTES_PER_ELEMENT,\n      6 * Float32Array.BYTES_PER_ELEMENT);\n    gl.drawElements(gl.TRIANGLES, vertexIndexBuffers[i].numItems, gl.UNSIGNED_SHORT, 0);\n  }\n}\n\n//modified from http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere\nfunction setupSphereData() {\n  for (let i = 0; i < num_spheres; ++i) {\n    let tex_scale_x = 1;\n    let tex_scale_y = 1;\n    let tex_start_x = 0;\n    let tex_start_y = 0;\n\n    const active_num = i % textureFilenames.length;\n    if (topHalf.indexOf(active_num) !== -1) {\n      tex_start_y = 0.5;\n      tex_scale_y = 0.5;\n    }\n\n    const latitudeBands = 30;\n    const longitudeBands = 30;\n    const radius = spherePositions[i].radius;\n\n    const interleavedData = [];\n    const indexData = [];\n\n    for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n      const theta = latNumber * Math.PI / latitudeBands;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n\n      for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n        const phi = longNumber * 2 * Math.PI / longitudeBands;\n        const sinPhi = Math.sin(phi);\n        const cosPhi = Math.cos(phi);\n\n        const x = cosPhi * sinTheta;\n        const y = cosTheta;\n        const z = sinPhi * sinTheta;\n        const u = 1 - (longNumber / longitudeBands);\n        const v = latNumber / latitudeBands;\n        const first = (latNumber * (longitudeBands + 1)) + longNumber;\n        const second = first + longitudeBands + 1;\n\n        //position\n        interleavedData.push(radius * x);\n        interleavedData.push(radius * y);\n        interleavedData.push(radius * z);\n\n        //normal\n        interleavedData.push(x);\n        interleavedData.push(y);\n        interleavedData.push(z);\n\n        //texture coordinates\n        interleavedData.push(u * tex_scale_x + tex_start_x);\n        interleavedData.push(v * tex_scale_y + tex_start_y);\n\n        //indices\n        if ((latNumber < latitudeBands) && (longNumber < longitudeBands)) {\n          indexData.push(first);\n          indexData.push(second);\n          indexData.push(first + 1);\n\n          indexData.push(second);\n          indexData.push(second + 1);\n          indexData.push(first + 1);\n        }\n      }\n    }\n\n    trianglesInterleavedBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, trianglesInterleavedBuffers[i]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(interleavedData), gl.STATIC_DRAW);\n    trianglesInterleavedBuffers[i].itemSize = 8;\n    trianglesInterleavedBuffers[i].numItems = interleavedData.length / 8;\n\n    vertexIndexBuffers[i] = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffers[i]);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STREAM_DRAW);\n    vertexIndexBuffers[i].itemSize = 3;\n    vertexIndexBuffers[i].numItems = indexData.length;\n  }\n}\n\nfunction getMatrixUniforms() {\n  glProgram.pMatrixUniform = gl.getUniformLocation(glProgram, 'uPMatrix');\n  glProgram.mvMatrixUniform = gl.getUniformLocation(glProgram, 'uMVMatrix');\n  glProgram.normalMatrixUniform = gl.getUniformLocation(glProgram, 'uNormalMatrix');\n  glProgram.samplerUniform = gl.getUniformLocation(glProgram, 'uSampler');\n}\n\nfunction setMatrixUniforms() {\n  gl.uniformMatrix4fv(glProgram.mvMatrixUniform, false, mvMatrix);\n  gl.uniformMatrix3fv(glProgram.normalMatrixUniform, false, normalMatrix);\n}\n\nfunction loadTextures() {\n  for (let i = 0; i < textureFilenames.length; ++i) {\n    loadTexture(i);\n  }\n  gl.uniform1i(glProgram.samplerUniform, textures[0]);\n}\n\nfunction loadTexture(i) {\n  textureImages[i] = new Image();\n  textureImages[i].onload = function () {\n    setupTexture(i);\n  };\n  textureImages[i].src = textureFilenames[i];\n}\n\nfunction setupTexture(i) {\n  gl.activeTexture(gl.TEXTURE0 + i);\n  textures[i] = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, textures[i]);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImages[i]);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\n  if (!gl.isTexture(textures[i])) {\n    console.error('Error: Texture is invalid');\n  }\n}\n"],"sourceRoot":""}